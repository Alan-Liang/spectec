;; Meta

syntax n = nat

var i : nat
var j : nat
var k : nat

syntax name hint(desc "name") = text


;; Values

syntax byte hint(desc "byte") = nat  ;; TODO
syntax u32 hint(desc "32-bit integer") = nat  ;; TODO

var b : byte


;; Indices

syntax idx hint(desc "index") = nat
syntax funcidx hint(desc "function index") = idx
syntax globalidx hint(desc "global index") = idx
syntax labelidx hint(desc "label index") = idx
syntax localidx hint(desc "local index") = idx

var x : idx
var y : idx
var l : labelidx


;; Types

syntax numtype hint(desc "number type") =
  | I32
syntax valtype hint(desc "value type") =
  | numtype | BOT

syntax in hint(show I#n) = | I32

var t : valtype
var nt : numtype

syntax resulttype hint(desc "result type") =
  valtype*

syntax globaltype hint(desc "global type") =
  MUT? valtype
syntax functype hint(desc "function type") =
  resulttype -> resulttype

var ft : functype
var gt : globaltype


;; Operators

syntax sx hint(desc "signedness") = | U | S

syntax unop_IXX = | CLZ | CTZ | POPCNT

syntax binop_IXX =
  | ADD | SUB | MUL | DIV sx hint(show DIV_#%) | REM sx hint(show REM_#%)
  | AND | OR | XOR | SHL | SHR sx hint(show SHR_#%) | ROTL | ROTR

syntax testop_IXX = | EQZ

syntax relop_IXX =
  | EQ | NE | LT sx hint(show LT_#%) | GT sx hint(show GT_#%) | LE sx hint(show LE_#%) | GE sx hint(show GE_#%)

syntax unop_numtype = | _I unop_IXX
syntax binop_numtype = | _I binop_IXX
syntax testop_numtype = | _I testop_IXX
syntax relop_numtype = | _I relop_IXX

var unop : unop_numtype
var binop : binop_numtype
var testop : testop_numtype
var relop : relop_numtype


;; Instructions

syntax c_numtype = nat  ;; TODO
var c : c_numtype

syntax blocktype hint(desc "block type") = functype  ;; TODO
var bt : blocktype

syntax instr/control hint(desc "control instruction") =
  | UNREACHABLE
  | NOP
  | DROP
  | SELECT valtype?
  | BLOCK blocktype instr*
  | LOOP blocktype instr*
  | IF blocktype instr* ELSE instr*
  | BR labelidx
  | BR_IF labelidx
  | CALL funcidx
  | RETURN
  | ...

syntax instr/numeric hint(desc "numeric instruction") = ...
  | CONST numtype c_numtype          hint(show %.CONST %)
  | UNOP numtype unop_numtype        hint(show %.%)
  | BINOP numtype binop_numtype      hint(show %.%)
  | TESTOP numtype testop_numtype    hint(show %.%)
  | RELOP numtype relop_numtype      hint(show %.%)
  | ...

syntax instr/state hint(desc "state instruction") = ...
  | LOCAL.GET localidx
  | LOCAL.SET localidx
  | LOCAL.TEE localidx
  | GLOBAL.GET globalidx
  | GLOBAL.SET globalidx

syntax expr hint(desc "expression") =
  instr*

syntax instr hint(desc "instruction")


;; Modules

syntax func hint(desc "function") =
  FUNC functype valtype* expr
syntax global hint(desc "global") =
  GLOBAL globaltype expr
syntax start hint(desc "start function") =
  START funcidx

syntax module hint(desc "module") =
  MODULE func* global* start*
;; General constants

def $Ki : nat
def $Ki = 1024


;; General functions

def $min(nat, nat) : nat
def $min(0, j) = 0
def $min(i, 0) = 0
def $min(i, j) = $min($(i - 1), $(j - 1))


;; Auxiliary Definitions on Types

;; def |I n| = |F n| = |V n| = n        ;; ????

def $size(valtype) : nat  hint(partial) hint(show |%|)
def $size(I32) = 32


;; Some notation tests

def $test_sub_ATOM_22(n_3_ATOM_y) : nat
def $test_sub_ATOM_22(n_3_ATOM_y) = 0

def $curried_(n, n) : nat
def $curried_(n_1, n_2) = $(n_1 + n_2)

syntax testfuse =
  | AB_ nat nat nat
  | CD nat nat nat  hint(show CD_% % %)
  | EF nat nat nat  hint(show EF_#% % %)
  | GH nat nat nat  hint(show GH_%#% %)
  | IJ nat nat nat  hint(show IJ_%#% %)
  | KL nat nat nat  hint(show KL_AB#% % %)
  | MN nat nat nat  hint(show MN_#AB % % %)
  | OP nat nat nat  hint(show OP_#AB#% % %)
  | QR nat nat nat  hint(show QR_%#AB % %)
;; Contexts

syntax context hint(desc "context") =
  { FUNC functype*, GLOBAL globaltype*,
    LOCAL valtype*, LABEL resulttype*, RETURNS resulttype? }

var C : context



;; Types

relation Functype_ok: |- functype : OK      hint(show "K-func")
relation Globaltype_ok: |- globaltype : OK  hint(show "K-global")


rule Functype_ok:
  |- ft : OK

rule Globaltype_ok:
  |- gt : OK


;; Instructions

relation Instr_ok: context |- instr : functype     hint(show "T")
relation InstrSeq_ok: context |- instr* : functype hint(show "T*")
relation Expr_ok: context |- expr : resulttype     hint(show "T-expr")


rule Expr_ok:
  C |- instr* : t*
  -- InstrSeq_ok: C |- instr* : epsilon -> t*


rule InstrSeq_ok/empty:
  C |- epsilon : epsilon -> epsilon

rule InstrSeq_ok/seq:
  C |- instr_1 instr_2* : t_1* -> t_3*
  -- Instr_ok: C |- instr_1 : t_1* -> t_2*
  -- InstrSeq_ok: C |- instr_2 : t_2* -> t_3*

rule InstrSeq_ok/weak:
  C |- instr* : t_1 -> t_2*
  -- InstrSeq_ok: C |- instr* : t_1* -> t_2*

rule InstrSeq_ok/frame:
  C |- instr* : t* t_1* -> t* t_2*
  -- InstrSeq_ok: C |- instr* : t_1* -> t_2*


rule Instr_ok/unreachable:
  C |- UNREACHABLE : t_1* -> t_2*

rule Instr_ok/nop:
  C |- NOP : epsilon -> epsilon

rule Instr_ok/drop:
  C |- DROP : t -> epsilon


rule Instr_ok/select-expl:
  C |- SELECT t : t t I32 -> t

rule Instr_ok/select-impl:
  C |- SELECT : t t I32 -> t
  -- if t = numtype


relation Blocktype_ok: context |- blocktype : functype hint(show "K-block")

rule Blocktype_ok:
  C |- ft : ft
  -- Functype_ok: |- ft : OK

rule Instr_ok/block:
  C |- BLOCK bt instr* : t_1* -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- InstrSeq_ok: C, LABEL t_2* |- instr* : t_1* -> t_2*

rule Instr_ok/loop:
  C |- LOOP bt instr* : t_1* -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- InstrSeq_ok: C, LABEL t_1* |- instr* : t_1* -> t_2*

rule Instr_ok/if:
  C |- IF bt instr_1* ELSE instr_2* : t_1* -> t_2*
  -- Blocktype_ok: C |- bt : t_1* -> t_2*
  -- InstrSeq_ok: C, LABEL t_2* |- instr_1* : t_1* -> t_2*
  -- InstrSeq_ok: C, LABEL t_2* |- instr_2* : t_1* -> t_2*


rule Instr_ok/br:
  C |- BR l : t_1* t* -> t_2*
  -- if C.LABEL[l] = t*

rule Instr_ok/br_if:
  C |- BR_IF l : t* I32 -> t*
  -- if C.LABEL[l] = t*

rule Instr_ok/return:
  C |- RETURN : t_1* t* -> t_2*
  -- if C.RETURNS = (t*)

rule Instr_ok/call:
  C |- CALL x : t_1* -> t_2*
  -- if C.FUNC[x] = t_1* -> t_2*


rule Instr_ok/const:
  C |- CONST nt c_nt : epsilon -> nt

rule Instr_ok/unop:
  C |- UNOP nt unop : nt -> nt

rule Instr_ok/binop:
  C |- BINOP nt binop : nt nt -> nt

rule Instr_ok/testop:
  C |- TESTOP nt testop : nt -> I32

rule Instr_ok/relop:
  C |- RELOP nt relop : nt nt -> I32


rule Instr_ok/local.get:
  C |- LOCAL.GET x : epsilon -> t
  -- if C.LOCAL[x] = t

rule Instr_ok/local.set:
  C |- LOCAL.SET x : t -> epsilon
  -- if C.LOCAL[x] = t

rule Instr_ok/local.tee:
  C |- LOCAL.TEE x : t -> t
  -- if C.LOCAL[x] = t


rule Instr_ok/global.get:
  C |- GLOBAL.GET x : epsilon -> t
  -- if C.GLOBAL[x] = MUT? t

rule Instr_ok/global.set:
  C |- GLOBAL.SET x : t -> epsilon
  -- if C.GLOBAL[x] = MUT t


;; Constant Expressions

relation Instr_const: context |- instr CONST             hint(show "C-instr")
relation Expr_const: context |- expr CONST               hint(show "C-expr")
relation Expr_ok_const: context |- expr : valtype CONST  hint(show "TC-expr")

rule Instr_const/const:
  C |- (CONST nt c) CONST

rule Instr_const/global.get:
  C |- (GLOBAL.GET x) CONST
  -- if C.GLOBAL[x] = epsilon t


rule Expr_const: C |- instr* CONST
  -- (Instr_const: C |- instr CONST)*


rule Expr_ok_const:
  C |- expr : t CONST
  -- Expr_ok: C |- expr : t
  -- Expr_const: C |- expr CONST


;; Modules

relation Func_ok: context |- func : functype         hint(show "T-func")
relation Global_ok: context |- global : globaltype   hint(show "T-global")
relation Start_ok: context |- start : OK             hint(show "T-start")


rule Func_ok:
  C |- FUNC ft t* expr : ft
  -- if ft = t_1* -> t_2*
  -- Functype_ok: |- ft : OK
  -- Expr_ok: C, LOCAL t_1* t*, LABEL (t_2*), RETURNS (t_2*) |- expr : t_2*

rule Global_ok:
  C |- GLOBAL gt expr : gt
  -- Globaltype_ok: |- gt : OK
  -- if gt = MUT? t
  -- Expr_ok_const: C |- expr : t CONST

rule Start_ok:
  C |- START x : OK
  -- if C.FUNC[x] = epsilon -> epsilon


relation Module_ok: |- module : OK      hint(show "T-module")

rule Module_ok:
  |- MODULE func* global* start* : OK
  ;; TODO: incremental contexts for globals
  -- if C = {FUNC ft*, GLOBAL gt*}

  -- (Func_ok: C |- func : ft)*
  -- (Global_ok: C |- global : gt)*

  -- (Start_ok: C |- start : OK)*

  -- if |start*| <= 1
  ;; -- TODO: disjoint export names
;; Addresses

syntax addr hint(desc "address") = nat
syntax funcaddr hint(desc "function address") = addr
syntax globaladdr hint(desc "global address") = addr
syntax labeladdr hint(desc "label address") = addr
syntax hostaddr hint(desc "host address") = addr

var a : addr
var fa : funcaddr
var ga : globaladdr


;; Values

syntax num hint(desc "number") =
  | CONST numtype c_numtype
syntax val hint(desc "value") =
  | num

syntax result hint(desc "result") =
  | _VALS val* | TRAP

var v : val
var res : result


def $default_(valtype) : val  hint(partial)
def $default_(I32) = (CONST I32 0)


;; Configurations

syntax funcinst hint(desc "function instance") = moduleinst; func
syntax globalinst hint(desc "global instance") = val

syntax store hint(desc "store") =
  { FUNC funcinst*,
    GLOBAL globalinst* }

syntax moduleinst hint(desc "module instance") =
  { FUNC funcaddr*,
    GLOBAL globaladdr* }

syntax frame hint(desc "frame") =
  { LOCAL val*,
    MODULE moduleinst }
syntax state hint(desc "state") = store; frame
syntax config hint(desc "configuration") = state; admininstr*

var s : store
var f : frame
var z : state

var m : moduleinst
var fi : funcinst
var gi : globalinst


;; Auxiliary notation

def $funcaddr(state) : funcaddr*  hint(show %.MODULE.FUNC)
def $funcaddr((s; f)) = f.MODULE.FUNC

def $funcinst(state) : funcinst*  hint(show %.FUNC)
def $funcinst((s; f)) = s.FUNC

def $func(state, funcidx) : funcinst        hint(show %.FUNC#`[%])
def $global(state, globalidx) : globalinst  hint(show %.GLOBAL#`[%])
def $local(state, localidx) : val           hint(show %.LOCAL#`[%])

def $func((s; f), x) = s.FUNC[f.MODULE.FUNC[x]]
def $global((s; f), x) = s.GLOBAL[f.MODULE.GLOBAL[x]]
def $local((s; f), x) = f.LOCAL[x]


def $with_local(state, localidx, val) : state     hint(show %[.LOCAL[%] = %])
def $with_global(state, globalidx, val) : state   hint(show %[.GLOBAL[%] = %])

def $with_local((s; f), x, v) = s; f[.LOCAL[x] = v]
def $with_global((s; f), x, v) = s[.GLOBAL[f.MODULE.GLOBAL[x]] = v]; f


;; Administrative Instructions

syntax admininstr hint(show instr) hint(desc "administrative instruction") =
  | instr
  | CALL_ADDR funcaddr             hint(show CALL %)
  | LABEL_ n `{instr*} admininstr* hint(show LABEL_%#% %%)
  | FRAME_ n `{frame} admininstr*  hint(show FRAME_%#% %%)
  | TRAP

syntax E hint(desc "evaluation context") =
  | _HOLE `[ _ ]
  | _SEQ val* E instr*
  | LABEL_ n `{instr*} E
;; TODO: how to do sets, definitions, etc.

def $unop(unop_numtype, numtype, c) : c_numtype*         hint(show %#_%#((%)))
def $binop(binop_numtype, numtype, c, c) : c_numtype*    hint(show %#_%#(%, %))
def $testop(testop_numtype, numtype, c) : c_numtype      hint(show %#_%#((%)))
def $relop(relop_numtype, numtype, c, c) : c_numtype     hint(show %#_%#(%, %))

;; Instructions

relation Step: config ~> config                 hint(show "E")
relation Step_pure: admininstr* ~> admininstr*  hint(show "E")
relation Step_read: config ~> admininstr*       hint(show "E")

rule Step/pure:
  z; instr*  ~>  z; instr'*
  -- Step_pure: instr* ~> instr'*

rule Step/read:
  z; instr*  ~>  z; instr'*
  -- Step_read: z; instr* ~> instr'*


rule Step_pure/unreachable:
  UNREACHABLE  ~>  TRAP

rule Step_pure/nop:
  NOP  ~>  epsilon

rule Step_pure/drop:
  val DROP  ~>  epsilon


rule Step_pure/select-true:
  val_1 val_2 (CONST I32 c) (SELECT t?)  ~>  val_1
  -- if c =/= 0

rule Step_pure/select-false:
  val_1 val_2 (CONST I32 c) (SELECT t?)  ~>  val_2
  -- if c = 0


rule Step_pure/block:
  val^k (BLOCK bt instr*)  ~>  (LABEL_ n `{epsilon} val^k instr*)
  -- if bt = t_1^k -> t_2^n

rule Step_pure/loop:
  val^k (LOOP bt instr*)  ~>  (LABEL_ n `{LOOP bt instr*} val^k instr*)
  -- if bt = t_1^k -> t_2^n

rule Step_pure/if-true:
  (CONST I32 c) (IF bt instr_1* ELSE instr_2*)  ~>  (BLOCK bt instr_1*)
  -- if c =/= 0

rule Step_pure/if-false:
  (CONST I32 c) (IF bt instr_1* ELSE instr_2*)  ~>  (BLOCK bt instr_2*)
  -- if c = 0


rule Step_pure/label-vals:
  (LABEL_ n `{instr*} val*)  ~>  val*


;; TODO: may want a label context instead of bubbling up
rule Step_pure/br-zero:
  (LABEL_ n `{instr'*} val'* val^n (BR 0) instr*)  ~>  val^n instr'*

rule Step_pure/br-succ:
  (LABEL_ n `{instr'*} val* (BR $(l+1)) instr*)  ~>  val* (BR l)


rule Step_pure/br_if-true:
  (CONST I32 c) (BR_IF l)  ~>  (BR l)
  -- if c =/= 0

rule Step_pure/br_if-false:
  (CONST I32 c) (BR_IF l)  ~>  epsilon
  -- if c = 0


rule Step_read/call:
  z; (CALL x)  ~>  (CALL_ADDR $funcaddr(z)[x])  ;; TODO

rule Step_read/call_addr:
  z; val^k (CALL_ADDR a)  ~>  (FRAME_ n `{f} (LABEL_ n `{epsilon} instr*))
  -- if $funcinst(z)[a] = m; FUNC (t_1^k -> t_2^n) t* instr*
  -- if f = {LOCAL val^k ($default_(t))*, MODULE m}


rule Step_pure/frame-vals:
  (FRAME_ n `{f} val^n)  ~>  val^n

rule Step_pure/return-frame:
  (FRAME_ n `{f} val'* val^n RETURN instr*)  ~>  val^n

rule Step_pure/return-label:
  (LABEL_ k `{instr'*} val* RETURN instr*)  ~>  val* RETURN


rule Step_pure/unop-val:
  (CONST nt c_1) (UNOP nt unop)  ~>  (CONST nt c)
  -- if $unop(unop, nt, c_1) = c  ;; TODO

rule Step_pure/unop-trap:
  (CONST nt c_1) (UNOP nt unop)  ~>  TRAP
  -- if $unop(unop, nt, c_1) = epsilon  ;; TODO


rule Step_pure/binop-val:
  (CONST nt c_1) (CONST nt c_2) (BINOP nt binop)  ~>  (CONST nt c)
  -- if $binop(binop, nt, c_1, c_2) = c  ;; TODO

rule Step_pure/binop-trap:
  (CONST nt c_1) (CONST nt c_2) (BINOP nt binop)  ~>  TRAP
  -- if $binop(binop, nt, c_1, c_2) = epsilon  ;; TODO


rule Step_pure/testop:
  (CONST nt c_1) (TESTOP nt testop)  ~>  (CONST I32 c)
  -- if c = $testop(testop, nt, c_1)

rule Step_pure/relop:
  (CONST nt c_1) (CONST nt c_2) (RELOP nt relop)  ~>  (CONST I32 c)
  -- if c = $relop(relop, nt, c_1, c_2)


rule Step_read/local.get:
  z; (LOCAL.GET x)  ~>  $local(z, x)

rule Step/local.set:
  z; val (LOCAL.SET x)  ~>  $with_local(z, x, val); epsilon

rule Step_pure/local.tee:
  val (LOCAL.TEE x)  ~>  val val (LOCAL.SET x)


rule Step_read/global.get:
  z; (GLOBAL.GET x)  ~>  $global(z, x)

rule Step/global.set:
  z; val (GLOBAL.SET x)  ~>  $with_global(z, x, val); epsilon
