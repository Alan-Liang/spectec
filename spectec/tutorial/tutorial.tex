\documentclass{article}
\usepackage{fullpage,fancyvrb,newverbs,xcolor,amsfonts, amsmath}

\definecolor{cverbbg}{gray}{0.93}

\newenvironment{cverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{cverbbg}{\BUseVerbatim{cverb}}%
  \endflushleft
}
\newenvironment{lcverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{cverbbg}{%
    \makebox[\dimexpr\linewidth-2\fboxsep][l]{\BUseVerbatim{cverb}}%
  }
  \endflushleft
}

\newcommand{\ctexttt}[1]{\colorbox{cverbbg}{\texttt{#1}}}
\newverbcommand{\cverb}
  {\setbox\verbbox\hbox\bgroup}
  {\egroup\colorbox{cverbbg}{\box\verbbox}}


\newcommand\X[1]{\mathit{#1}}
\newcommand\K[1]{\texttt{#1}}

\date{}

\begin{document}
\title{Mini-Wasm Tutorial}
\maketitle

\section{Introduction}
In this tutorial, we will practice how to write a spec in Wasm-DSL.
Here, instead of a full Wasm, a very simplified version of Wasm (which we call Mini-Wasm) is used as our goal.

\subsection{Working Directory}
The directory \K{<root>/spectec/tutorial} is where we will work on.

\subsection{How To Run}
Running \K{make} in \K{<root>/spectec} will yield an executable file \K{watsup} in same directory. You can use this to generate various types of spec. For example, in directory \K{<root>/spectec}:
\begin{lcverbatim}
./watsup ./tutorial/*.watsup --prose
\end{lcverbatim}
will generate prose, using every \K{./watsup} file in directory \K{./tutorial} as input. There are various options including \K{--interpreter}, \K{--latex}, or \K{--print-il}. You can see all possible options with command \K{./watsup -help}.

\section{Basic Building Blocks of Wasm-DSL}
First, we'll study basic building blocks of Wasm-DSL, and how to use them. \\
For now, You don't have to understand this part completely. You may start from Section 3, and refer to this section when you want to.

\subsection{Syntax Definitions}
Syntax definitions describe the grammar of the input language or auxiliary constructs. These are essentially type definitions for Wasm-DSL.
\begin{lcverbatim}
syntax <name_of_syntax> = <case> | ... | <case>
\end{lcverbatim}
Defining syntax in Wasm-DSL is basically done as above. Use keyword \K{syntax}, write the name of syntax in lowercase, and simply list the possible cases with the separator \K{|}. Here, each of the case can be a nonterminal node (usually written in lowercases) which refers to another syntax, or a terminal node (usually written in uppercases).

\subsection{Variable Declarations}
Variable declarations ascribe the syntactic class (i.e., type) that meta variables used in rules range over.
\begin{lcverbatim}
var <name_of_var> : <type>
\end{lcverbatim}
We can explicitly declare a metavariable as above. Use keyword \K{var}, and give its name and type. Here, \K{<type>} may be a complex form, which contains iteration, parametric syntax, etc.\\
Also, every syntax name is implicitly usable as a variable of the respective type.

\subsection{Relation Declarations}
Relation declarations, defining the shape of judgement forms, such as typing or reduction relations. These are essentially type declarations for the meta language. For example:
\begin{lcverbatim}
relation Instr_ok: context |- instr : functype
relation Step: config ~> config
\end{lcverbatim}
%\begin{lcverbatim}
%relation <name_of_relation>: context |- <type> : <type>
%relation <name_of_relation>: <type> ~> <type>
%\end{lcverbatim}

\subsection{Rule Definitions}
\begin{lcverbatim}
rule <name_of_relation>/<name_of_rule>:
  <content_of_rule>
\end{lcverbatim}
We can define the individual rules for each relation as above. \K{<content\_of\_rule>} has different form, depending on its relation.
Every rule is named, so that it can be referenced. Each premise is introduced by a dash and includes the name of the relation it is referencing, easing checking and processing.

\subsection{Auxiliary Functions}
\begin{lcverbatim}
def $<func_name>(<type_of_arg1>, <type_of_arg2>, ... , <type_of_argn>) : <result_type>
def $<func_name>(<arg1>, <arg2>, ... , <argn>) = <result>
\end{lcverbatim}
We can declare auxiliary functions as above. The first line indicates the type of arguments and result of the function. The second line is function body, which describes how the actual result comes out. \\

\section{Syntax}
Now, we will start from writing the syntax of Mini-Wasm.
Abstract syntax of Mini-Wasm is as follows:

$$
\begin{array}{@{}lrrl@{}l@{}}
	& N &::=& \mathbb{N} \\
	& n &::=& \mathbb{N} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(integer)} & {\mathit{iN}}(N) &::=& 0 ~|~ \dots ~|~ {2^{N}} - 1 \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(character)} & {\mathit{char}} &::=& \mathrm{U{+}00} ~|~ \dots ~|~ \mathrm{U{+}D7FF} ~|~ \mathrm{U{+}E000} ~|~ \dots ~|~ \mathrm{U{+}10FFFF} \\
	\mbox{(name)} & {\mathit{name}} &::=& {{\mathit{char}}^\ast} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(index)} & {\mathit{idx}} &::=& {\mathit{iN}}(32) \\
	\mbox{(type index)} & {\mathit{typeidx}} &::=& {\mathit{idx}} \\
	\mbox{(function index)} & {\mathit{funcidx}} &::=& {\mathit{idx}} \\
	\mbox{(label index)} & {\mathit{labelidx}} &::=& {\mathit{idx}} \\
	\mbox{(local index)} & {\mathit{localidx}} &::=& {\mathit{idx}} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(number type)} & {\mathit{valtype}} &::=& \mathsf{i{\scriptstyle 32}} ~|~ \mathsf{i{\scriptstyle 64}} \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(function type)} & {\mathit{functype}} &::=& {{\mathit{valtype}}^\ast} \rightarrow {{\mathit{valtype}}^\ast} \\
	\mbox{(external type)} & {\mathit{externtype}} &::=& \mathsf{func}~{\mathit{functype}} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{size}}(\mathsf{i{\scriptstyle 32}}) &=& 32 \\
	{\mathrm{size}}(\mathsf{i{\scriptstyle 64}}) &=& 64 \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}l@{}}
	& {{\mathit{num}}}_{{\mathit{valtype}}} &::=& {\mathit{iN}}({\mathrm{size}}({\mathit{valtype}})) \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	& {\mathit{binop}} &::=& \mathsf{add} ~|~ \mathsf{sub} ~|~ \mathsf{mul} ~|~ \mathsf{div} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(instruction)} & {\mathit{instr}} &::=& \mathsf{nop} \\ &&|&
	\mathsf{drop} \\ &&|&
	\mathsf{select} \\ &&|&
	\mathsf{block}~{\mathit{functype}}~{{\mathit{instr}}^\ast} \\ &&|&
	\mathsf{loop}~{\mathit{functype}}~{{\mathit{instr}}^\ast} \\ &&|&
	\mathsf{if}~{\mathit{functype}}~{{\mathit{instr}}^\ast}~\mathsf{else}~{{\mathit{instr}}^\ast} \\ &&|&
	\mathsf{br}~{\mathit{labelidx}} \\ &&|&
	\mathsf{br\_if}~{\mathit{labelidx}} \\ &&|&
	\mathsf{call}~{\mathit{funcidx}} \\ &&|&
	\mathsf{return} \\ &&|&
	\mathsf{const}~{\mathit{valtype}}~{{\mathit{num}}}_{{\mathit{valtype}}} \\ &&|&
	\mathsf{binop}~{\mathit{valtype}}~{\mathit{binop}} \\ &&|&
	\mathsf{local.get}~{\mathit{localidx}} \\ &&|&
	\mathsf{local.set}~{\mathit{localidx}} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(expression)} & {\mathit{expr}} &::=& {{\mathit{instr}}^\ast} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(type)} & {\mathit{type}} &::=& \mathsf{type}~{\mathit{functype}} \\
	\mbox{(local)} & {\mathit{local}} &::=& \mathsf{local}~{\mathit{valtype}} \\
	\mbox{(function)} & {\mathit{func}} &::=& \mathsf{func}~{\mathit{typeidx}}~{{\mathit{local}}^\ast}~{\mathit{expr}} \\
	\mbox{(external index)} & {\mathit{externidx}} &::=& \mathsf{func}~{\mathit{funcidx}} \\
	\mbox{(export)} & {\mathit{export}} &::=& \mathsf{export}~{\mathit{name}}~{\mathit{externidx}} \\
	\mbox{(module)} & {\mathit{module}} &::=& \mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{export}}^\ast} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(address)} & {\mathit{addr}} &::=& \mathbb{N} \\
	\mbox{(function address)} & {\mathit{funcaddr}} &::=& {\mathit{addr}} \\
\end{array}
$$

\vspace{1ex}

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(value)} & {\mathit{val}} &::=& \mathsf{const}~{\mathit{valtype}}~{{\mathit{num}}}_{{\mathit{valtype}}} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(external value)} & {\mathit{externval}} &::=& \mathsf{func}~{\mathit{funcaddr}} \\
\end{array}
$$

\vspace{1ex}

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(function instance)} & {\mathit{funcinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{type}~{\mathit{functype}},\; \\
		\mathsf{module}~{\mathit{moduleinst}},\; \\
		\mathsf{code}~{\mathit{func}} \}\end{array} \\
	\mbox{(export instance)} & {\mathit{exportinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{name}~{\mathit{name}},\; \\
		\mathsf{value}~{\mathit{externval}} \}\end{array} \\
	\mbox{(module instance)} & {\mathit{moduleinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{types}~{{\mathit{functype}}^\ast},\; \\
		\mathsf{funcs}~{{\mathit{funcaddr}}^\ast},\; \\
		\mathsf{exports}~{{\mathit{exportinst}}^\ast} \}\end{array} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(store)} & {\mathit{store}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{funcs}~{{\mathit{funcinst}}^\ast} \}\end{array} \\
	\mbox{(frame)} & {\mathit{frame}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{locals}~{{\mathit{val}}^\ast},\; \\
		\mathsf{module}~{\mathit{moduleinst}} \}\end{array} \\
	\mbox{(state)} & {\mathit{state}} &::=& {\mathit{store}} ; {\mathit{frame}} \\
	\mbox{(configuration)} & {\mathit{config}} &::=& {\mathit{state}} ; {{\mathit{admininstr}}^\ast} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(administrative instruction)} & {\mathit{admininstr}} &::=& {\mathit{instr}} \\ &&|&
	\mathsf{call\_addr}~{\mathit{funcaddr}} \\ &&|&
	{\mathsf{label}}_{n}\,\{ {{\mathit{instr}}^\ast} \}~{{\mathit{admininstr}}^\ast} \\ &&|&
	{\mathsf{frame}}_{n}\,\{ {\mathit{frame}} \}~{{\mathit{admininstr}}^\ast} \\ &&|&
	\mathsf{trap} \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{funcaddr}}((s ; f)) &=& f{.}\mathsf{module}{.}\mathsf{funcs} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{local}}((s ; f), x) &=& f{.}\mathsf{locals}{}[x] \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{with}}_{\mathit{local}}((s ; f), x, v) &=& s ; f{}[{.}\mathsf{locals}{}[x] = v] \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{funcinst}}((s ; f)) &=& s{.}\mathsf{funcs} \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
	{{\mathrm{default}}}_{\mathsf{i{\scriptstyle 32}}} &=& (\mathsf{const}~\mathsf{i{\scriptstyle 32}}~0) \\
	{{\mathrm{default}}}_{\mathsf{i{\scriptstyle 64}}} &=& (\mathsf{const}~\mathsf{i{\scriptstyle 64}}~0) \\
\end{array}
$$
\\
Make a new file \K{1-syntax.wastup}. \\
We'll declare each of the syntax one by one.

\subsection{$N$, $n$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	& N &::=& \mathbb{N} \\
	& n &::=& \mathbb{N} \\
\end{array}
$$
This syntax is simply written in Wasm-DSL like this:
\begin{lcverbatim}
syntax N = nat
syntax n = nat
\end{lcverbatim}
Here, \K{nat} is a pre-defined syntax, which indicates any natural number.
This means the syntax \K{N} and \K{n} is a natural number.

\subsection{${i}{N}$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(integer)} & {\mathit{iN}}(N) &::=& 0 ~|~ \dots ~|~ {2^{N}} - 1 \\
\end{array}
$$
\begin{lcverbatim}
syntax iN(N) = 0 | ... | 2^N-1
\end{lcverbatim}
Now, the syntax \K{iN} is declared in regard with parameter \K{N}. Also, you can use \K{...} to indicate a range.

\subsection{$char$, $name$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(character)} & {\mathit{char}} &::=& \mathrm{U{+}00} ~|~ \dots ~|~ \mathrm{U{+}D7FF} ~|~ \mathrm{U{+}E000} ~|~ \dots ~|~ \mathrm{U{+}10FFFF} \\
	\mbox{(name)} & {\mathit{name}} &::=& {{\mathit{char}}^\ast} \\
\end{array}
$$
We need a declaration of $name$, which indicates for a general string. We can declare a syntax for a character like this:
\begin{lcverbatim}
syntax char = U+0000 | ... | U+D7FF | U+E000 | ... | U+10FFFF
\end{lcverbatim}
This syntax is built-in, and denotes Unicode code points.
Now, \K{name} is simply an iteration of \K{char}s. Use \K{*} to represent a sequence.
\begin{lcverbatim}
syntax name = char*
\end{lcverbatim}

\subsection{$idx$, $typeidx$, $funcidx$, $labelidx$, $localidx$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(index)} & {\mathit{idx}} &::=& {\mathit{iN}}(32) \\
	\mbox{(type index)} & {\mathit{typeidx}} &::=& {\mathit{idx}} \\
	\mbox{(function index)} & {\mathit{funcidx}} &::=& {\mathit{idx}} \\
	\mbox{(label index)} & {\mathit{labelidx}} &::=& {\mathit{idx}} \\
	\mbox{(local index)} & {\mathit{localidx}} &::=& {\mathit{idx}} \\
\end{array}
$$
\begin{lcverbatim}
syntax idx = I32
\end{lcverbatim}
Since we have four types of index (which are semantically same, but syntactically different), write like this:
\begin{lcverbatim}
syntax typeidx = idx
syntax funcidx = idx
syntax labelidx = idx
syntax localidx = idx
\end{lcverbatim}

\subsection{$\mathit{valtype}$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(number type)} & {\mathit{valtype}} &::=& \mathsf{i{\scriptstyle 32}} ~|~ \mathsf{i{\scriptstyle 64}} \\
\end{array}
$$
\begin{lcverbatim}
syntax valtype = I32 | I64
\end{lcverbatim}

\subsection{$\mathit{functype}$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(function type)} & {\mathit{functype}} &::=& {{\mathit{valtype}}^\ast} \rightarrow {{\mathit{valtype}}^\ast} \\
\end{array}
$$
We can use \K{->} to indicate a function:
\begin{lcverbatim}
syntax functype = valtype* -> valtype*
\end{lcverbatim}

\subsection{$\mathit{externtype}$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(external type)} & {\mathit{externtype}} &::=& \mathsf{func}~{\mathit{functype}} \\
\end{array}
$$
\begin{lcverbatim}
syntax externtype = FUNC functype
\end{lcverbatim}

\subsection{$size$, ${{\mathit{num}}}_{{\mathit{valtype}}}$}
$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{size}}(\mathsf{i{\scriptstyle 32}}) &=& 32 \\
	{\mathrm{size}}(\mathsf{i{\scriptstyle 64}}) &=& 64 \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}l@{}}
	& {{\mathit{num}}}_{{\mathit{valtype}}} &::=& {\mathit{iN}}({\mathrm{size}}({\mathit{valtype}})) \\
\end{array}
$$
\begin{lcverbatim}
syntax num_(valtype) = iN($size(valtype))
\end{lcverbatim}
The first line declares the syntax \K{num\_}, and the remaining lines give the actual definition. \\
We'll redefine this syntax later on Section 4.2, using function \K{size}.

\subsection{$binop$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	& {\mathit{binop}} &::=& \mathsf{add} ~|~ \mathsf{sub} ~|~ \mathsf{mul} ~|~ \mathsf{div} \\
\end{array}
$$
\begin{lcverbatim}
syntax binop = ADD | SUB | MUL | DIV
\end{lcverbatim}

\subsection{$instr$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(instruction)} & {\mathit{instr}} &::=& \mathsf{nop} \\ &&|&
	\mathsf{drop} \\ &&|&
	\mathsf{select} \\ &&|&
	\mathsf{block}~{\mathit{functype}}~{{\mathit{instr}}^\ast} \\ &&|&
	\mathsf{loop}~{\mathit{functype}}~{{\mathit{instr}}^\ast} \\ &&|&
	\mathsf{if}~{\mathit{functype}}~{{\mathit{instr}}^\ast}~\mathsf{else}~{{\mathit{instr}}^\ast} \\ &&|&
	\mathsf{br}~{\mathit{labelidx}} \\ &&|&
	\mathsf{br\_if}~{\mathit{labelidx}} \\ &&|&
	\mathsf{call}~{\mathit{funcidx}} \\ &&|&
	\mathsf{return} \\ &&|&
	{\mathit{valtype}}{.}\mathsf{const}~{{\mathit{num}}}_{{\mathit{valtype}}} \\ &&|&
	{\mathit{valtype}} {.} {\mathit{binop}} \\ &&|&
	\mathsf{local.get}~{\mathit{localidx}} \\ &&|&
	\mathsf{local.set}~{\mathit{localidx}} \\
\end{array}
$$
\begin{lcverbatim}
syntax instr =
  | NOP
  | DROP
  | SELECT
  | BLOCK functype instr*
  | LOOP functype instr*
  | IF functype instr* ELSE instr*
  | BR labelidx
  | BR_IF labelidx
  | CALL funcidx
  | RETURN
  | CONST valtype num_(valtype)
  | BINOP valtype binop
  | LOCAL.GET localidx
  | LOCAL.SET localidx
\end{lcverbatim}

\subsection{$expr$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(expression)} & {\mathit{expr}} &::=& {{\mathit{instr}}^\ast} \\
\end{array}
$$
\begin{lcverbatim}
syntax expr = instr*
\end{lcverbatim}

\subsection{$module$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(type)} & {\mathit{type}} &::=& \mathsf{type}~{\mathit{functype}} \\
	\mbox{(local)} & {\mathit{local}} &::=& \mathsf{local}~{\mathit{valtype}} \\
	\mbox{(function)} & {\mathit{func}} &::=& \mathsf{func}~{\mathit{typeidx}}~{{\mathit{local}}^\ast}~{\mathit{expr}} \\
	\mbox{(external index)} & {\mathit{externidx}} &::=& \mathsf{func}~{\mathit{funcidx}} \\
	\mbox{(export)} & {\mathit{export}} &::=& \mathsf{export}~{\mathit{name}}~{\mathit{externidx}} \\
	\mbox{(module)} & {\mathit{module}} &::=& \mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{export}}^\ast} \\
\end{array}
$$
Declare $module$ and its subcomponents as follows:
\begin{lcverbatim}
syntax type = TYPE functype
syntax local = LOCAL valtype
syntax func = FUNC typeidx local* expr
syntax externidx = FUNC funcidx
syntax export = EXPORT name externidx
syntax module = MODULE type* func* export*
\end{lcverbatim}

\subsection{$addr$, $funcaddr$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(address)} & {\mathit{addr}} &::=& \mathbb{N} \\
	\mbox{(function address)} & {\mathit{funcaddr}} &::=& {\mathit{addr}} \\
\end{array}
$$
\begin{lcverbatim}
syntax addr = nat
syntax funcaddr = addr
\end{lcverbatim}

\subsection{$val$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(value)} & {\mathit{val}} &::=& \mathsf{const}~{\mathit{valtype}}~{{\mathit{num}}}_{{\mathit{valtype}}} \\
\end{array}
$$
\begin{lcverbatim}
syntax val = CONST valtype num_(valtype)
\end{lcverbatim}

\subsection{$externval$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(external value)} & {\mathit{externval}} &::=& \mathsf{func}~{\mathit{funcaddr}} \\
\end{array}
$$
\begin{lcverbatim}
syntax externval = FUNC funcaddr
\end{lcverbatim}

\subsection{$funcinst$, $exportinst$, $moduleinst$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(function instance)} & {\mathit{funcinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{type}~{\mathit{functype}},\; \\
		\mathsf{module}~{\mathit{moduleinst}},\; \\
		\mathsf{code}~{\mathit{func}} \}\end{array} \\
	\mbox{(export instance)} & {\mathit{exportinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{name}~{\mathit{name}},\; \\
		\mathsf{value}~{\mathit{externval}} \}\end{array} \\
	\mbox{(module instance)} & {\mathit{moduleinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{types}~{{\mathit{functype}}^\ast},\; \\
		\mathsf{funcs}~{{\mathit{funcaddr}}^\ast},\; \\
		\mathsf{exports}~{{\mathit{exportinst}}^\ast} \}\end{array} \\
\end{array}
$$
\begin{lcverbatim}
syntax funcinst =
{ TYPE functype,
	MODULE moduleinst,
	CODE func }
syntax exportinst =
{ NAME name,
	VALUE externval }

syntax moduleinst =
{ TYPES functype*,
	FUNCS funcaddr*,
	EXPORTS exportinst* }
\end{lcverbatim}

\subsection{$store$, $frame$, $state$, $config$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(store)} & {\mathit{store}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{funcs}~{{\mathit{funcinst}}^\ast} \}\end{array} \\
	\mbox{(frame)} & {\mathit{frame}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
		\mathsf{locals}~{{\mathit{val}}^\ast},\; \\
		\mathsf{module}~{\mathit{moduleinst}} \}\end{array} \\
	\mbox{(state)} & {\mathit{state}} &::=& {\mathit{store}} ; {\mathit{frame}} \\
	\mbox{(configuration)} & {\mathit{config}} &::=& {\mathit{state}} ; {{\mathit{admininstr}}^\ast} \\
\end{array}
$$
\begin{lcverbatim}
syntax store =
{ FUNCS funcinst* }

syntax frame =
{ LOCALS val*,
	MODULE moduleinst }

syntax state = store; frame
syntax config = state; admininstr*
\end{lcverbatim}

\subsection{$admininstr$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(administrative instruction)} & {\mathit{admininstr}} &::=& {\mathit{instr}} \\ &&|&
	\mathsf{call\_addr}~{\mathit{funcaddr}} \\ &&|&
	{\mathsf{label}}_{n}\,\{ {{\mathit{instr}}^\ast} \}~{{\mathit{admininstr}}^\ast} \\ &&|&
	{\mathsf{frame}}_{n}\,\{ {\mathit{frame}} \}~{{\mathit{admininstr}}^\ast} \\ &&|&
	\mathsf{trap} \\
\end{array}
$$
\begin{lcverbatim}
syntax admininstr =
| instr
| CALL_ADDR funcaddr
| LABEL_ n `{instr*} admininstr*
| FRAME_ n `{frame} admininstr*
| TRAP
\end{lcverbatim}

\subsection{$\mathrm{funcaddr}$}
$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{funcaddr}}((s ; f)) &=& f{.}\mathsf{module}{.}\mathsf{funcs} \\
\end{array}
$$
\begin{lcverbatim}
def $funcaddr(state) : funcaddr*
def $funcaddr((s; f)) = f.MODULE.FUNCS
\end{lcverbatim}

\subsection{$\mathrm{local}$}
$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{local}}((s ; f), x) &=& f{.}\mathsf{locals}{}[x] \\
\end{array}
$$
\begin{lcverbatim}
def $local(state, localidx) : val
def $local((s; f), x) = f.LOCALS[x]
\end{lcverbatim}

\subsection{$\mathrm{with_{\mathit{local}}}$}
$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{with}}_{\mathit{local}}((s ; f), x, v) &=& s ; f{}[{.}\mathsf{locals}{}[x] = v] \\
\end{array}
$$
\begin{lcverbatim}
def $with_local(state, localidx, val) : state
def $with_local((s; f), x, v) = s; f[.LOCALS[x] = v]
\end{lcverbatim}

\subsection{$\mathrm{funcinst}$}
$$
\begin{array}{@{}lcl@{}l@{}}
	{\mathrm{funcinst}}((s ; f)) &=& s{.}\mathsf{funcs} \\
\end{array}
$$
\begin{lcverbatim}
def $funcinst(state) : funcinst*
def $funcinst((s; f)) = s.FUNCS
\end{lcverbatim}

\subsection{${{\mathrm{default}}}_{valtype}$}
$$
\begin{array}{@{}lcl@{}l@{}}
	{{\mathrm{default}}}_{\mathsf{i{\scriptstyle 32}}} &=& (\mathsf{const}~\mathsf{i{\scriptstyle 32}}~0) \\
	{{\mathrm{default}}}_{\mathsf{i{\scriptstyle 64}}} &=& (\mathsf{const}~\mathsf{i{\scriptstyle 64}}~0) \\
\end{array}
$$
\begin{lcverbatim}
def $default_(valtype) : val
def $default_(I32) = (CONST I32 0)
def $default_(I64) = (CONST I64 0)
\end{lcverbatim}

\section{Metavariables}
We're done with writing syntax of Mini-Wasm. Now, we will declare metavariables, which is used in reduction rules. \\
There are three ways to make use of metavariables.

\subsection{Explicit Declarartion}
Declare variables in file \K{1-syntax.wastup} as follows:
\begin{lcverbatim}
var x : idx
var l : labelidx
var t : valtype
var ft : functype
var in : instr
var e : instr*
var ty : type
var loc : local
var ex : export
var st : start
\end{lcverbatim}

\subsection{Using Syntax Name}
Also, we can use the syntax name directly as a variable of same type. For example, instead of below code:
\begin{lcverbatim}
rule Step/example:
  z; (CONST t c_1) (CONST t c_2)  ~>  z; (CONST t c_1)
\end{lcverbatim}

we can write like this:
\begin{lcverbatim}
rule Step/example:
  z; (CONST valtype c_1) (CONST valtype c_2)  ~>  z; (CONST valtype c_1)
\end{lcverbatim}

\subsection{Using Without Declaration}
%\subsection{Implicit declaration? Infer? Using without declaration?}
Finally, we can use a metavariable without declaration in suitable situations. In this case, its type will be inferred. Now, we may rewrite the above rule as:
\begin{lcverbatim}
rule Step/example:
  z; (CONST anyname c_1) (CONST anyname c_2)  ~>  z; (CONST anyname c_1)
\end{lcverbatim}

\section{Functions}
\subsection{Declaring Function Body}
Function body can be multiple cases, which defines a function by pattern matching. \\
For example, we can define a function \K{size}, which returns the size of a \K{valtype} as:
\begin{lcverbatim}
def $size(valtype) : nat
def $size(I32) = 32
def $size(I64) = 64
\end{lcverbatim}
Now, the function \K{size} will return \K{32} for input \K{I32}, and \K{64} for input \K{I64}. \\
\\
We can also add condition to a function body. \\
For example, we can define a function \K{min}, which returns a smaller integer between two:
\begin{lcverbatim}
def $min(nat, nat) : nat
def $min(i, j) = i
  -- if i < j
def $min(i, j) = j
\end{lcverbatim}
Now, the function \K{min} will return \K{i} if \K{i < j}, else \K{j}.

%\subsection{Built-in Functions}
%Here are some built-in functions that we can use:
%\begin{lcverbatim}
%$ibytes
%$inverse_of_ibytes
%$nbytes
%$vbytes
%...
%\end{lcverbatim}
%You can find their definition from the file \K{<root>/spectec/src/backend-interpreter/numerics.ml}.
%Also, even though they are built-in, you should declare their type first, and use them in Wasm-DSL.
%
\subsection{Using Functions}
Functions can be used in definition of other functions or reduction rules. When using function, write as below form:
\begin{lcverbatim}
$<func_name>(<arg1>, <arg2>, ... , <argn>)
\end{lcverbatim}
For example, put the definition of the function \K{size} before the syntax \K{num\_} from Section 2.7.
Then, we can use \K{size} to redefine \K{num\_} as below:
\begin{lcverbatim}
syntax num_(valtype) = iN($size(valtype))
\end{lcverbatim}

\section{Reduction Rules}
Now, let's write the reduction rules for the instructions.
First, make a new file \K{8-reduction.wastup} and write as follows:
\begin{lcverbatim}
relation Step: config ~> config
\end{lcverbatim}
It means that \K{rule}s of \K{relation Step} receives \K{config} as its input and then yields new \K{config} as its output. Here, \K{config} is defined in file \K{4-runtime.watsup}:
\begin{lcverbatim}
syntax config = state; admininstr*
syntax admininstr =
  | instr
  | CALL_ADDR funcaddr
  | LABEL_ n `{instr*} admininstr*
  | FRAME_ n `{frame} admininstr*
  | TRAP
\end{lcverbatim}
As you can see, \K{config} is a pair of \K{state} and sequence of \K{admininstr}. \K{admininstr} is a superset of \K{instr}, which contains some additional administrative instructions.\\ Declaring reduction rule in Wasm-DSL is basically done like this:
\begin{lcverbatim}
rule Step/<rule name>:
  <input state>; <input instructions>  ~>  <output state>; <output instructions>
  -- if <condition>
  ...
  -- if <condition>
\end{lcverbatim}
This means that if every \K{condition} is satisfied, then the state and instructions from stack is reduced to the right hand side. There may be no conditions. \\
Now we'll declare each of the reduction rules one by one.

\subsection{\K{NOP}}
%\K{NOP} means 'no operation', so if we get \K{NOP} from stack, we can just remove it from stack. \\
Use \K{eps} to indicate an empty instruction sequence. \\
Use metavariable \K{z} for a \K{state}. \\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/nop:
  z; NOP  ~>  z; eps
	\end{lcverbatim}
}

\subsection{\K{DROP}}
%If we get \K{DROP} from stack, then we should remove a value from stack. \\
Use following syatax \K{val}, which is defined in \K{4-runtime.watsup}:
\begin{lcverbatim}
syntax val = CONST valtype val_(valtype)
\end{lcverbatim}
as a variable. \\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/drop:
  z; val DROP  ~>  z; eps
	\end{lcverbatim}
}

\subsection{\K{SELECT}}
When we get \K{SELECT} from stack, we have two cases: condition is true or false. \\
Define each of the case as seperate rule as follows:
\begin{lcverbatim}
rule Step/select-true:
  ...

rule Step/select-false:
  ...
\end{lcverbatim}
Write like \K{val\_1}, \K{val\_2} (and so on) to distinguish multiple \K{val}s. \\
Use \K{=/=} and \K{=} for integer comparison.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/select-true:
  z; val_1 val_2 (CONST I32 c) SELECT  ~>  z; val_1
  -- if c =/= 0

rule Step/select-false:
  z; val_1 val_2 (CONST I32 c) SELECT  ~>  z; val_2
  -- if c = 0
	\end{lcverbatim}
	As you can see here, you can distinguish multiple metavariables with same type by adding \K{\_1}, \K{\_2} (and so on) after the metavariable name.
	Also, the names of two rules should be the same before hyphen (-), so that they can be prosed as the same reduction rule.
}

\subsection{\K{BINOP}}
When we get \K{BINOP} from stack, there are three cases for \K{binop\_(valtype)}: \K{ADD}, \K{SUB}, \K{MUL}. \\
Define each of the case as seperate rule, and use built-in functions \K{iadd}, \K{isub}, \K{imul} as follows:
\begin{lcverbatim}
def $iadd(N, iN(N), iN(N)) : iN(N)
def $isub(N, iN(N), iN(N)) : iN(N)
def $imul(N, iN(N), iN(N)) : iN(N)
def $iadd(N, c_1, c_2) = $((c_1 + c_2) \ 2^N)
def $isub(N, c_1, c_2) = $((c_1 - c_2) \ 2^N)
def $imul(N, c_1, c_2) = $((c_1 * c_2) \ 2^N)

rule Step/binop-add:
  ...

rule Step/binop-sub:
  ...

rule Step/binop-mul:
  ...
\end{lcverbatim}
Use function \K{size}, which is defined from subsection 4.1.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
def $iadd(N, iN(N), iN(N)) : iN(N)
def $isub(N, iN(N), iN(N)) : iN(N)
def $imul(N, iN(N), iN(N)) : iN(N)

rule Step/binop-add:
  z; (CONST t c_1) (CONST t c_2) (BINOP t ADD)  ~>  z; (CONST t c)
-- if $iadd($size(t), c_1, c_2) = c

rule Step/binop-sub:
z; (CONST t c_1) (CONST t c_2) (BINOP t SUB)  ~>  z; (CONST t c)
-- if $isub($size(t), c_1, c_2) = c

rule Step/binop-mul:
z; (CONST t c_1) (CONST t c_2) (BINOP t MUL)  ~>  z; (CONST t c)
-- if $imul($size(t), c_1, c_2) = c
	\end{lcverbatim}
	Now, we may combine them by declaring a new function \K{binop} as follows:
	\begin{lcverbatim}
def $iadd(N, iN(N), iN(N)) : iN(N)
def $isub(N, iN(N), iN(N)) : iN(N)
def $imul(N, iN(N), iN(N)) : iN(N)

def $binop(valtype, binop_(valtype), val_(valtype), val_(valtype)) : val_(valtype)*
def $binop(t, ADD, c_1, c_2) = $iadd($size(t), c_1, c_2)
def $binop(t, SUB, c_1, c_2) = $isub($size(t), c_1, c_2)
def $binop(t, MUL, c_1, c_2) = $imul($size(t), c_1, c_2)

rule Step/binop:
  z; (CONST t c_1) (CONST t c_2) (BINOP t binop)  ~>  z; (CONST t c)
  -- if $binop(t, binop, c_1, c_2) = c
	\end{lcverbatim}
}

\subsection{\K{BLOCK}}
To indicate a label, refer to following syntax:
\begin{lcverbatim}
LABEL_ n `{instr*} admininstr*
\end{lcverbatim}
$\\$
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/block-eps:
  z; (BLOCK eps instr*)  ~>  z; (LABEL_ 0 `{eps} instr*)
rule Step/block-val:
  z; (BLOCK t instr*)  ~>  z; (LABEL_ 1 `{eps} instr*)
	\end{lcverbatim}
	Here, you may combine them by using \K{/\symbol{92}} for `and', \K{\symbol{92}/} for `or', and \K{?} for an optional argument:
	\begin{lcverbatim}
rule Step/block:
  z; (BLOCK t? instr*)  ~>  z; (LABEL_ n `{eps} instr*)
  -- if t? = eps /\ n = 0 \/ t? =/= eps /\ n = 1
	\end{lcverbatim}
}

\subsection{\K{LOOP}}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/loop:
  z; (LOOP t? instr*)  ~>  z; (LABEL_ 0 `{LOOP t? instr*} instr*)
	\end{lcverbatim}
}

\subsection{\K{IF}}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/if-true:
z; (CONST I32 c) (IF t? instr_1* ELSE instr_2*)  ~>  z; (BLOCK t? instr_1*)
-- if c =/= 0

rule Step/if-false:
z; (CONST I32 c) (IF t? instr_1* ELSE instr_2*)  ~>  z; (BLOCK t? instr_2*)
-- if c = 0
	\end{lcverbatim}
}

\subsection{\K{BR}}
For arithmetic expressions, you should write like \K{\$(l+1)}, instead of \K{l+1}.\\
Use \K{\^} for a sequence with given length. e.g. \K{instr}\K{\^}\K{n}. \\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/br-zero:
z; (LABEL_ n `{instr'*} val'* val^n (BR 0) instr*)  ~>  z; val^n instr'*

rule Step/br-succ:
z; (LABEL_ n `{instr'*} val* (BR $(l+1)) instr*)  ~>  z; val* (BR l)
	\end{lcverbatim}
}

\subsection{\K{BR\_IF}}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/br_if-true:
  z; (CONST I32 c) (BR_IF l)  ~>  z; (BR l)
  -- if c =/= 0

rule Step/br_if-false:
  z; (CONST I32 c) (BR_IF l)  ~>  z; eps
  -- if c = 0
	\end{lcverbatim}
}

\subsection{\K{CALL}}
To get a sequence of \K{funcaddr} from \K{state z}, write \K{\$funcaddr(z)}.\\
To get \K{n}th element of sequence \K{seq}, write \K{seq[n]}.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/call:
  z; (CALL x)  ~>  z; (CALL_ADDR $funcaddr(z)[x])
	\end{lcverbatim}
}

\subsection{\K{FRAME}}
To indicate a frame, refer to following syntax:
\begin{lcverbatim}
FRAME_ n `{frame} admininstr*
\end{lcverbatim}
$\\$
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/frame-vals:
  z; (FRAME_ n `{f} val^n)  ~>  z; val^n
	\end{lcverbatim}
}

\subsection{\K{RETURN}}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/return-frame:
  z; (FRAME_ n `{f} val'* val^n RETURN instr*)  ~>  z; val^n

rule Step/return-label:
  z; (LABEL_ n `{instr'*} val* RETURN instr*)  ~>  z; val* RETURN
	\end{lcverbatim}
}

\subsection{\K{LOCAL.GET}}
To get a local value from \K{state z} and \K{idx x}, write \K{\$local(z, x)}.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/local.get:
  z; (LOCAL.GET x)  ~>  z; $local(z, x)
	\end{lcverbatim}
}

\subsection{\K{LOCAL.SET}}
To get a new state which is exactly same with \K{state z} except that its local value with \K{idx x} is \K{val v}, write \K{\$with\_local(z, x, v)}.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/local.set:
  z; val (LOCAL.SET x)  ~>  $with_local(z, x, val); eps
	\end{lcverbatim}
}


%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(address)} & {\mathit{addr}} &::=& {\mathit{nat}} \\
%	\mbox{(function address)} & {\mathit{funcaddr}} &::=& {\mathit{addr}} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(value)} & {\mathit{val}} &::=& {\mathit{valtype}}{.}\mathsf{const}~{{\mathit{val}}}_{{\mathit{valtype}}} \\
%	\mbox{(result)} & {\mathit{result}} &::=& {{\mathit{val}}^\ast} ~|~ \mathsf{trap} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(external value)} & {\mathit{externval}} &::=& \mathsf{func}~{\mathit{funcaddr}} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(function instance)} & {\mathit{funcinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{type}~{\mathit{functype}},\; \\
%		\mathsf{module}~{\mathit{moduleinst}},\; \\
%		\mathsf{code}~{\mathit{func}} \}\end{array} \\
%	\mbox{(export instance)} & {\mathit{exportinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{name}~{\mathit{name}},\; \\
%		\mathsf{value}~{\mathit{externval}} \}\end{array} \\
%	\mbox{(module instance)} & {\mathit{moduleinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{types}~{{\mathit{functype}}^\ast},\; \\
%		\mathsf{funcs}~{{\mathit{funcaddr}}^\ast},\; \\
%		\mathsf{exports}~{{\mathit{exportinst}}^\ast} \}\end{array} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(store)} & {\mathit{store}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{funcs}~{{\mathit{funcinst}}^\ast} \}\end{array} \\
%	\mbox{(frame)} & {\mathit{frame}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{locals}~{{\mathit{val}}^\ast},\; \\
%		\mathsf{module}~{\mathit{moduleinst}} \}\end{array} \\
%	\mbox{(state)} & {\mathit{state}} &::=& {\mathit{store}} ; {\mathit{frame}} \\
%	\mbox{(configuration)} & {\mathit{config}} &::=& {\mathit{state}} ; {{\mathit{instr}}^\ast} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(administrative instruction)} & {\mathit{instr}} &::=& {\mathit{instr}} \\ &&|&
%	\mathsf{call}~{\mathit{funcaddr}} \\ &&|&
%	{{\mathsf{label}}_{n}}{\{{{\mathit{instr}}^\ast}\}}~{{\mathit{instr}}^\ast} \\ &&|&
%	{{\mathsf{frame}}_{n}}{\{{\mathit{frame}}\}}~{{\mathit{instr}}^\ast} \\ &&|&
%	\mathsf{trap} \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	(s ; f){.}\mathsf{module}{.}\mathsf{funcs} &=& f{.}\mathsf{module}{.}\mathsf{funcs} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	(s ; f){.}\mathsf{locals}{}[x] &=& f{.}\mathsf{locals}{}[x] \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	(s ; f){}[\mathsf{locals}{}[x] = v] &=& s ; f{}[\mathsf{locals}{}[x] = v] \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	(s ; f){.}\mathsf{funcs} &=& s{.}\mathsf{funcs} \\
%\end{array}
%$$
%
%${{\mathit{config}} \hookrightarrow {\mathit{config}}}$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}nop}]} \quad & z ; \mathsf{nop} &\hookrightarrow& z ; \epsilon \\
%	{[\textsc{\scriptsize E{-}drop}]} \quad & z ; {\mathit{val}}~\mathsf{drop} &\hookrightarrow& z ; \epsilon \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}select{-}true}]} \quad & z ; {\mathit{val}}_1~{\mathit{val}}_2~(\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~\mathsf{select} &\hookrightarrow& z ; {\mathit{val}}_1
%	&\qquad \mbox{if}~c \neq 0 \\
%	{[\textsc{\scriptsize E{-}select{-}false}]} \quad & z ; {\mathit{val}}_1~{\mathit{val}}_2~(\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~\mathsf{select} &\hookrightarrow& z ; {\mathit{val}}_2
%	&\qquad \mbox{if}~c = 0 \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}block}]} \quad & z ; (\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; ({{\mathsf{label}}_{n}}{\{\epsilon\}}~{{\mathit{instr}}^\ast})
%	&\qquad \mbox{if}~{t^?} = \epsilon \land n = 0 \lor {t^?} \neq \epsilon \land n = 1 \\
%	{[\textsc{\scriptsize E{-}loop}]} \quad & z ; (\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; ({{\mathsf{label}}_{0}}{\{\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast}\}}~{{\mathit{instr}}^\ast}) \\
%	{[\textsc{\scriptsize E{-}if{-}true}]} \quad & z ; (\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~(\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast}) &\hookrightarrow& z ; (\mathsf{block}~{t^?}~{{\mathit{instr}}_1^\ast})
%	&\qquad \mbox{if}~c \neq 0 \\
%	{[\textsc{\scriptsize E{-}if{-}false}]} \quad & z ; (\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~(\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast}) &\hookrightarrow& z ; (\mathsf{block}~{t^?}~{{\mathit{instr}}_2^\ast})
%	&\qquad \mbox{if}~c = 0 \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}br{-}zero}]} \quad & z ; ({{\mathsf{label}}_{n}}{\{{{\mathit{instr}'}^\ast}\}}~{{\mathit{val}'}^\ast}~{{\mathit{val}}^{n}}~(\mathsf{br}~0)~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; {{\mathit{val}}^{n}}~{{\mathit{instr}'}^\ast} \\
%	{[\textsc{\scriptsize E{-}br{-}succ}]} \quad & z ; ({{\mathsf{label}}_{n}}{\{{{\mathit{instr}'}^\ast}\}}~{{\mathit{val}}^\ast}~(\mathsf{br}~l + 1)~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; {{\mathit{val}}^\ast}~(\mathsf{br}~l) \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}br\_if{-}true}]} \quad & z ; (\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~(\mathsf{br\_if}~l) &\hookrightarrow& z ; (\mathsf{br}~l)
%	&\qquad \mbox{if}~c \neq 0 \\
%	{[\textsc{\scriptsize E{-}br\_if{-}false}]} \quad & z ; (\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~(\mathsf{br\_if}~l) &\hookrightarrow& z ; \epsilon
%	&\qquad \mbox{if}~c = 0 \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}call}]} \quad & z ; (\mathsf{call}~x) &\hookrightarrow& z ; (\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]) \\
%	{[\textsc{\scriptsize E{-}frame{-}vals}]} \quad & z ; ({{\mathsf{frame}}_{n}}{\{f\}}~{{\mathit{val}}^{n}}) &\hookrightarrow& z ; {{\mathit{val}}^{n}} \\
%	{[\textsc{\scriptsize E{-}return{-}frame}]} \quad & z ; ({{\mathsf{frame}}_{n}}{\{f\}}~{{\mathit{val}'}^\ast}~{{\mathit{val}}^{n}}~\mathsf{return}~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; {{\mathit{val}}^{n}} \\
%	{[\textsc{\scriptsize E{-}return{-}label}]} \quad & z ; ({{\mathsf{label}}_{n}}{\{{{\mathit{instr}'}^\ast}\}}~{{\mathit{val}}^\ast}~\mathsf{return}~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; {{\mathit{val}}^\ast}~\mathsf{return} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{{\mathsf{add}}{{}_{t}}}{(c_1,\, c_2)} &=& {{\mathrm{iadd}}}_{{|t|}}(c_1, c_2) \\
%	{{\mathsf{sub}}{{}_{t}}}{(c_1,\, c_2)} &=& {{\mathrm{isub}}}_{{|t|}}(c_1, c_2) \\
%	{{\mathsf{mul}}{{}_{t}}}{(c_1,\, c_2)} &=& {{\mathrm{imul}}}_{{|t|}}(c_1, c_2) \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}binop{-}val}]} \quad & z ; (t{.}\mathsf{const}~c_1)~(t{.}\mathsf{const}~c_2)~(t . {\mathit{binop}}) &\hookrightarrow& z ; (t{.}\mathsf{const}~c)
%	&\qquad \mbox{if}~{{{\mathit{binop}}}{{}_{t}}}{(c_1,\, c_2)} = c \\
%	{[\textsc{\scriptsize E{-}binop{-}trap}]} \quad & z ; (t{.}\mathsf{const}~c_1)~(t{.}\mathsf{const}~c_2)~(t . {\mathit{binop}}) &\hookrightarrow& z ; \mathsf{trap}
%	&\qquad \mbox{if}~{{{\mathit{binop}}}{{}_{t}}}{(c_1,\, c_2)} = \epsilon \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}local.get}]} \quad & z ; (\mathsf{local.get}~x) &\hookrightarrow& z ; z{.}\mathsf{locals}{}[x] \\
%	{[\textsc{\scriptsize E{-}local.set}]} \quad & z ; {\mathit{val}}~(\mathsf{local.set}~x) &\hookrightarrow& z{}[\mathsf{locals}{}[x] = {\mathit{val}}] ; \epsilon \\
%	{[\textsc{\scriptsize E{-}local.tee}]} \quad & z ; {\mathit{val}}~(\mathsf{local.tee}~x) &\hookrightarrow& z ; {\mathit{val}}~{\mathit{val}}~(\mathsf{local.set}~x) \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{funcs}}(\epsilon) &=& \epsilon \\
%	{\mathrm{funcs}}((\mathsf{func}~{\mathit{fa}})~{{\mathit{externval}'}^\ast}) &=& {\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externval}'}^\ast}) \\
%	{\mathrm{funcs}}({\mathit{externval}}~{{\mathit{externval}'}^\ast}) &=& {\mathrm{funcs}}({{\mathit{externval}'}^\ast})
%	&\qquad \mbox{otherwise} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{allocfunc}}(s, {\mathit{mm}}, {\mathit{func}}) &=& (s{}[\mathsf{funcs} = ..{\mathit{fi}}],\, {|s{.}\mathsf{funcs}|})
%	&\qquad \mbox{if}~{\mathit{fi}} = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{type}~{\mathit{mm}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array} \\
%	&&&\qquad {\land}~{\mathit{func}} = \mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}} \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{allocfuncs}}(s, {\mathit{mm}}, \epsilon) &=& (s,\, \epsilon) \\
%	{\mathrm{allocfuncs}}(s, {\mathit{mm}}, {\mathit{func}}~{{\mathit{func}'}^\ast}) &=& (s_2,\, {\mathit{fa}}~{{\mathit{fa}'}^\ast})
%	&\qquad \mbox{if}~(s_1,\, {\mathit{fa}}) = {\mathrm{allocfunc}}(s, {\mathit{mm}}, {\mathit{func}}) \\
%	&&&\qquad {\land}~(s_2,\, {{\mathit{fa}'}^\ast}) = {\mathrm{allocfuncs}}(s_1, {\mathit{mm}}, {{\mathit{func}'}^\ast}) \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{instexport}}({{\mathit{fa}}^\ast}, \mathsf{export}~{\mathit{name}}~(\mathsf{func}~x)) &=& \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{name}~{\mathit{name}},\; \mathsf{value}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array} \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externval}}^\ast}) &=& (s_1,\, {\mathit{mm}})
%	&\qquad \mbox{if}~{\mathit{module}} = \begin{array}[t]{@{}l@{}} \mathsf{module} \\ {(\mathsf{type}~{\mathit{ft}})^\ast} \\ {{\mathit{func}}^{n_{\mathit{func}}}} \\ {{\mathit{start}}^?} \\ {{\mathit{export}}^\ast} \end{array} \\
%	&&&\qquad {\land}~{{\mathit{fa}}_{\mathit{ex}}^\ast} = {\mathrm{funcs}}({{\mathit{externval}}^\ast}) \\
%	&&&\qquad {\land}~{{\mathit{fa}}^\ast} = {{|s{.}\mathsf{funcs}|} + i_{\mathit{func}}^{i_{\mathit{func}}<n_{\mathit{func}}}} \\
%	&&&\qquad {\land}~{{\mathit{xi}}^\ast} = {{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {\mathit{export}})^\ast} \\
%	&&&\qquad {\land}~{\mathit{mm}} = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{types}~{{\mathit{ft}}^\ast},\; \\
%		\mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \\
%		\mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array} \\
%	&&&\qquad {\land}~(s_1,\, {{\mathit{fa}}^\ast}) = {\mathrm{allocfuncs}}(s, {\mathit{mm}}, {{\mathit{func}}^{n_{\mathit{func}}}}) \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externval}}^\ast}) &=& s_1 ; f ; {(\mathsf{call}~{x'})^?}
%	&\qquad \mbox{if}~{\mathit{module}} = \mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast} \\
%	&&&\qquad {\land}~{{\mathit{type}}^\ast} = {(\mathsf{type}~{\mathit{functype}})^\ast} \\
%	&&&\qquad {\land}~{{\mathit{start}}^?} = {(\mathsf{start}~{x'})^?} \\
%	&&&\qquad {\land}~n_{\mathsf{f}} = {|{{\mathit{func}}^\ast}|} \\
%	&&&\qquad {\land}~{\mathit{mm}}_{\mathit{init}} = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{types}~{{\mathit{functype}}^\ast},\; \\
%		\mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externval}}^\ast})~{{|s{.}\mathsf{funcs}|} + i_{\mathsf{f}}^{i_{\mathsf{f}}<n_{\mathsf{f}}}} \}\end{array} \\
%	&&&\qquad {\land}~f_{\mathit{init}} = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{module}~{\mathit{mm}}_{\mathit{init}} \}\end{array} \\
%	&&&\qquad {\land}~z = s ; f_{\mathit{init}} \\
%	&&&\qquad {\land}~(s_1,\, {\mathit{mm}}) = {\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externval}}^\ast}) \\
%	&&&\qquad {\land}~f = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{module}~{\mathit{mm}} \}\end{array} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}}) &=& s ; f ; {{\mathit{val}}^{n}}~(\mathsf{call}~{\mathit{fa}})
%	&\qquad \mbox{if}~f = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{module}~\{ \begin{array}[t]{@{}l@{}}
%			\}\end{array} \}\end{array} \\
%	&&&\qquad {\land}~(s ; f){.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type} = {t_1^{n}} \rightarrow {t_2^\ast} \\
%\end{array}
%$$

\end{document}
