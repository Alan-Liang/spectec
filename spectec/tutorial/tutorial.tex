\documentclass{article}
\usepackage{fullpage,fancyvrb,newverbs,xcolor,amsfonts, amsmath}

\definecolor{cverbbg}{gray}{0.93}

\newenvironment{cverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{cverbbg}{\BUseVerbatim{cverb}}%
  \endflushleft
}
\newenvironment{lcverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{cverbbg}{%
    \makebox[\dimexpr\linewidth-2\fboxsep][l]{\BUseVerbatim{cverb}}%
  }
  \endflushleft
}

\newcommand{\ctexttt}[1]{\colorbox{cverbbg}{\texttt{#1}}}
\newverbcommand{\cverb}
  {\setbox\verbbox\hbox\bgroup}
  {\egroup\colorbox{cverbbg}{\box\verbbox}}


\newcommand\X[1]{\mathit{#1}}
\newcommand\K[1]{\texttt{#1}}

\date{}

\begin{document}
\title{Mini-Wasm Tutorial}
\maketitle

\section{Introduction}
In this tutorial, we will practice how to write a spec in Wasm-DSL.
Here, instead of a full Wasm, a very simplified version of Wasm (which we call Mini-Wasm) is used as our goal.

\subsection{Working Directory}
The directory \K{<root>/spectec/tutorial} is where we will work on.

\subsection{How To Run}
Running \K{make} in \K{<root>/spectec} will yield an executable file \K{watsup} in same directory. You can use this to generate various types of spec. For example, in directory \K{<root>/spectec}:
\begin{lcverbatim}
./watsup ./tutorial/*.watsup --prose
\end{lcverbatim}
will generate prose, using every \K{./watsup} file in directory \K{./tutorial} as input. There are various options including \K{--interpreter}, \K{--latex}, or \K{--print-il}. You can see all possible options with command \K{./watsup -help}.

\section{Building Blocks of Wasm-DSL}
First, we'll study building blocks of Wasm-DSL, and how to use them. \\
(For now, You don't have to understand this part completely. You may start from Section 3, and refer to this section when you want to.)

\subsection{Syntax Definitions}
Syntax definitions describe the grammar of the input language or auxiliary constructs. These are essentially type definitions for Wasm-DSL.
\begin{lcverbatim}
syntax <name_of_syntax> = <case> | <case> | <case>
\end{lcverbatim}
Defining syntax in Wasm-DSL is basically done as above. Use keyword \K{syntax}, write the name of syntax in lowercase, and simply list the possible cases with the separator \K{|}. Here, each of the case can be a nonterminal node (usually written in lowercases) which refers to another syntax, or a terminal node (usually written in uppercases).

\subsection{Variable Declarations}
Variable declarations ascribe the syntactic class (i.e., type) that meta variables used in rules range over.
\begin{lcverbatim}
var <name_of_var> : <type>
\end{lcverbatim}
We can explicitly declare a metavariable as above. Use keyword \K{var}, and give its name and type. Here, \K{<type>} may be a complex form, which contains iteration, parametric syntax, etc.\\
\\
Also, every syntax name is implicitly usable as a variable of the respective type. For example, instead of below code:
\begin{lcverbatim}
var t : valtype

rule Step/example:
  z; (CONST t c_1) (CONST t c_2)  ~>  z; (CONST t c_1)
\end{lcverbatim}
we can write like this:
\begin{lcverbatim}
rule Step/example:
  z; (CONST valtype c_1) (CONST valtype c_2)  ~>  z; (CONST valtype c_1)
\end{lcverbatim}
Also, we can use a metavariable without declaration in suitable situations. In this case, its type will be inferred. Now, we may rewrite the above rule as:
\begin{lcverbatim}
rule Step/example:
  z; (CONST anyname c_1) (CONST anyname c_2)  ~>  z; (CONST anyname c_1)
\end{lcverbatim}

\subsection{Relation Declarations}
Relation declarations, defining the shape of judgement forms, such as typing or reduction relations. These are essentially type declarations for the meta language. \\
Below is a general form of relation, which is quite brief:
\begin{lcverbatim}
relation <name_of_relation>: <content_of_relation>
\end{lcverbatim}
Content of relation may vary. For example, general form of typing relation will be:
\begin{lcverbatim}
relation <name_of_relation>: <type_of_context> |- <type> : <type>
\end{lcverbatim}
or, general form of reduction relation will be:
\begin{lcverbatim}
relation <name_of_relation>: <type> ~> <type>
\end{lcverbatim}
%You will see how relations work in Section 5 and 6.

\subsection{Rule Definitions}
\begin{lcverbatim}
rule <name_of_relation>/<name_of_rule>:
  <content_of_rule>
  -- <name_of_other_relation>: <premise>
  -- if <condition>
\end{lcverbatim}
We can define the individual rules for each relation as above. \K{<content\_of\_rule>} has different form, depending on its relation.
Every rule is named, so that it can be referenced. \\
You can add premises by including the name of referenced relation, and conditions using keyword \K{if}.\\

\subsection{Auxiliary Functions}
\begin{lcverbatim}
def $<func_name>(<type_of_arg1>, <type_of_arg2>, ... , <type_of_argn>) : <result_type>
def $<func_name>(<arg1>, <arg2>, ... , <argn>) = <result>
\end{lcverbatim}
We can declare auxiliary functions as above. The first line indicates the type of arguments and result of the function. The second line is function body, which describes how the actual result comes out. \\
Function body can be multiple cases, which defines a function by pattern matching. \\
For example, we can define a function \K{size}, which returns the size of a \K{valtype} as:
\begin{lcverbatim}
def $size(valtype) : nat
def $size(I32) = 32
def $size(I64) = 64
\end{lcverbatim}
Now, the function \K{size} will return \K{32} for input \K{I32}, and \K{64} for input \K{I64}. \\
\\
We can also add condition to a function body. \\
For example, we can define a function \K{min}, which returns a smaller integer between two:
\begin{lcverbatim}
def $min(nat, nat) : nat
def $min(i, j) = i
  -- if i < j
def $min(i, j) = j
\end{lcverbatim}
Now, the function \K{min} will return \K{i} if \K{i < j}, else \K{j}. \\
Functions can be used when defining other functions or reduction rules. When using function, write as below form:
\begin{lcverbatim}
$<func_name>(<arg1>, <arg2>, ... , <argn>)
\end{lcverbatim}
For example, you can use the function \K{size} to define the syntax \K{num\_} as below:
\begin{lcverbatim}
syntax num_(valtype) = iN($size(valtype))
\end{lcverbatim}

\section{Basic Syntax}
Now, we will start from writing the basic syntax of Mini-Wasm.
Refer to Appendix A.1 for a full version. \\
Make a new file \K{1-syntax.wastup} and write on it. \\
We'll declare each of the syntax one by one.

\subsection{$N$, $n$}
##{syntax+: {N n}}
Use a pre-defined syntax \K{nat}, to indicate any natural number.\\
Hint: Refer to Subsection 2.1. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax N = nat
syntax n = nat
	\end{lcverbatim}
This means the syntax \K{N} and \K{n} is a natural number.
}

\subsection{${i}{N}$}
##{syntax+: {iN}}
You can declare a parametric syntax as below:
\begin{lcverbatim}
syntax <name_of_syntax>(<parameter>) = <case> | <case> | <case>
\end{lcverbatim}
where \K{<case>}s contain \K{<parameter>}. \\
Use \K{...} to indicate a range. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax iN(N) = 0 | ... | 2^N-1
	\end{lcverbatim}
Now, the syntax \K{iN} is declared in regard with parameter \K{N}.
}

\subsection{$char$, $name$}
##{syntax+: {char name}}
Use a built-in syntax like below:
\begin{lcverbatim}
U+0000 | ... | U+1111
\end{lcverbatim}
to indicate a range of Unicode code points. \\
Use \K{*} to represent a sequence. \\
{\color{red}
	Answer:
%We need a declaration of $name$, which indicates for a general string. We can declare a syntax for a character like this:
	\begin{lcverbatim}
syntax char = U+0000 | ... | U+D7FF | U+E000 | ... | U+10FFFF
syntax name = char*
	\end{lcverbatim}
}

\subsection{$idx$, $typeidx$, $funcidx$, $labelidx$, $localidx$}
##{syntax+: idx {typeidx funcidx labelidx localidx}}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax idx = iN(32)
syntax typeidx = idx
syntax funcidx = idx
syntax labelidx = idx
syntax localidx = idx
	\end{lcverbatim}
%	Note that four types of index  are semantically same, but syntactically different.
}

\subsection{$\mathit{valtype}$}
##{syntax+: valtype}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax valtype = I32 | I64
	\end{lcverbatim}
}

\subsection{$\mathit{functype}$}
##{syntax+: functype}
Use \K{->} to indicate a function: \\
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax functype = valtype* -> valtype*
	\end{lcverbatim}
}

\subsection{$\mathit{externtype}$}
##{syntax+: externtype}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax externtype = FUNC functype
	\end{lcverbatim}
}

\subsection{$\mathrm{size}$, ${{\mathit{num}}}_{{\mathit{valtype}}}$}
##{definition: size}
##{syntax+: num_}
You need to declare an auxiliary function named \K{size} here. About auxiliary function, refer to Subsection 2.5. \\
Hint: The type declaration of function \K{size} is as follows:
\begin{lcverbatim}
def $size(valtype) : nat
\end{lcverbatim}
{\color{red}
	Answer:
	\begin{lcverbatim}
def $size(valtype) : nat
def $size(I32) = 32
def $size(I64) = 64

syntax num_(valtype) = iN($size(valtype))
	\end{lcverbatim}
The first line declares the type of function \K{size}, and the next two lines give the actual definition of it. Then, you can use \K{size} to declare \K{num\_}. \\
}

\subsection{$binop$}
##{syntax+: binop}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax binop = ADD | SUB | MUL | DIV
	\end{lcverbatim}
}

\subsection{$instr$}
##{syntax+: instr}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax instr =
  | NOP
  | DROP
  | SELECT
  | BLOCK functype instr*
  | LOOP functype instr*
  | IF functype instr* ELSE instr*
  | BR labelidx
  | BR_IF labelidx
  | CALL funcidx
  | RETURN
  | CONST valtype num_(valtype)
  | BINOP valtype binop
  | LOCAL.GET localidx
  | LOCAL.SET localidx
	\end{lcverbatim}
}

\subsection{$expr$}
##{syntax+: expr}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax expr = instr*
	\end{lcverbatim}
}

\subsection{$module$}
##{syntax+: {type local func externidx export module}}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax type = TYPE functype
syntax local = LOCAL valtype
syntax func = FUNC typeidx local* expr
syntax externidx = FUNC funcidx
syntax export = EXPORT name externidx
syntax module = MODULE type* func* export*
	\end{lcverbatim}
}

\subsection{Metavariables}
Declare metavariables for some basic syntax as below:
\begin{lcverbatim}
var i : nat
var x : idx
var l : labelidx
var t : valtype
var ft : functype
var in : instr
var e : expr
\end{lcverbatim}

\section{Runtime-Related Syntax}
Refer to Appendix A-2 for a full version. \\
Make a new file \K{2-runtime.wastup} and write on it. \\

\subsection{$addr$, $funcaddr$}
##{syntax+: {addr funcaddr}}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax addr = nat
syntax funcaddr = addr
	\end{lcverbatim}
}

\subsection{$val$}
##{syntax+: val}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax val = CONST valtype num_(valtype)
	\end{lcverbatim}
}

\subsection{$externval$}
##{syntax+: externval}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax externval = FUNC funcaddr
	\end{lcverbatim}
}

\subsection{$funcinst$, $exportinst$, $moduleinst$}
##{syntax+: {funcinst exportinst moduleinst}}
Use \K{\{} and \K{\}} to indicate records. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax funcinst =
  { TYPE functype,
    MODULE moduleinst,
    CODE func }
syntax exportinst =
  { NAME name,
    VALUE externval }
syntax moduleinst =
  { TYPES functype*,
    FUNCS funcaddr*,
    EXPORTS exportinst* }
	\end{lcverbatim}
}

\subsection{$store$, $frame$, $state$, $config$}
##{syntax+: {store frame state config}}
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax store = { FUNCS funcinst* }

syntax frame =
  { LOCALS val*,
    MODULE moduleinst }

syntax state = store; frame
syntax config = state; admininstr*
	\end{lcverbatim}
}

\subsection{$admininstr$}
##{syntax+: admininstr}
Write like below to indicate ??:
\begin{lcverbatim}
`{<syntax>}
\end{lcverbatim}
to avoid confusion with records. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
syntax admininstr =
  | instr
  | LABEL_ n `{instr*} admininstr*
  | FRAME_ n `{frame} admininstr*
  | TRAP
	\end{lcverbatim}
}

\subsection{$\mathrm{funcaddr}$}
##{definition: funcaddr}
Hint: The type declaration of function \K{funcaddr} is as follows:
\begin{lcverbatim}
def $funcaddr(state) : funcaddr*
\end{lcverbatim}
{\color{red}
	Answer:
	\begin{lcverbatim}
def $funcaddr(state) : funcaddr*
def $funcaddr((s; f)) = f.MODULE.FUNCS
	\end{lcverbatim}
}

\subsection{$\mathrm{local}$}
##{definition: local}
Use \K{[} and \K{]} to indicate an index. \\
Hint: The type declaration of function \K{local} is as follows:
\begin{lcverbatim}
def $local(state, localidx) : val
\end{lcverbatim}
{\color{red}
	Answer:
	\begin{lcverbatim}
def $local(state, localidx) : val
def $local((s; f), x) = f.LOCALS[x]
	\end{lcverbatim}
}

\subsection{$\mathrm{with_{\mathit{local}}}$}
##{definition: with_local}
Hint: The type declaration of function \K{with\_local} is as follows:
\begin{lcverbatim}
def $with_local(state, localidx, val) : state
\end{lcverbatim}
{\color{red}
	Answer:
	\begin{lcverbatim}
def $with_local(state, localidx, val) : state
def $with_local((s; f), x, v) = s; f[.LOCALS[x] = v]
	\end{lcverbatim}
}

\subsection{$\mathrm{funcinst}$}
##{definition: funcinst}
Hint: The type declaration of function \K{funcinst} is as follows:
\begin{lcverbatim}
def $funcinst(state) : funcinst*
\end{lcverbatim}
{\color{red}
	Answer:
	\begin{lcverbatim}
def $funcinst(state) : funcinst*
def $funcinst((s; f)) = s.FUNCS
	\end{lcverbatim}
}

\subsection{${{\mathrm{default}}}_{valtype}$}
##{definition: default_}
Hint: The type declaration of function \K{default\_} is as follows:
\begin{lcverbatim}
def $default_(valtype) : val
\end{lcverbatim}
{\color{red}
	Answer:
	\begin{lcverbatim}
def $default_(valtype) : val
def $default_(I32) = (CONST I32 0)
def $default_(I64) = (CONST I64 0)
	\end{lcverbatim}
}

\subsection{Metavariables}
Declare metavariables for some runtime-related syntax as below:
\begin{lcverbatim}
var a : addr
var fa : funcaddr
var v : val
var xv : externval
var mm : moduleinst
var fi : funcinst
var xi : exportinst
var s : store
var f : frame
var z : state
var ty : type
var loc : local
var ex : export
var xx : externidx
\end{lcverbatim}

\section{Validation Rules}
We're done with writing syntax of Mini-Wasm. Now, we will declare validation rules of Mini-Wasm. \\
Refer to Appendix A-3 for a full version. \\
Make a new file \K{3-typing.watsup} and write on it. \\

\subsection{$\mathit{context}$}
##{syntax+: context}
{\color{red}
	Answer:
%Define \K{context} and its metavariable as below:
	\begin{lcverbatim}
syntax context =
{ TYPES functype*, FUNCS functype*, 
  LOCALS valtype*, LABELS resulttype*, RETURN resulttype? }
	\end{lcverbatim}
	Additionally, define its metavariable as below:
	\begin{lcverbatim}
var C : context
	\end{lcverbatim}
}

\subsection{Types}
##{relation: Functype_ok}
##{relation: Externtype_ok}
Name the two relations \K{Functype\_ok}, and \K{Externtype\_ok}. \\
Use \K{OK} to indicate the type is valid. \\
Hint: Refer to Subsection 2.3. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
relation Functype_ok: |- functype : OK
relation Externtype_ok: |- externtype : OK
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Functype\_ok}}
##{rule+: Functype_ok}
Hint: Refer to Subsection 2.4. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Functype_ok:
  |- t_1* -> t_2? : OK
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Externtype\_ok-func}}
##{rule+: Externtype_ok/func}
Premise of $[\textsc{\scriptsize Externtype\_ok{-}func}]$ comes from relation \K{Functype\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Externtype_ok/func:
  |- FUNC functype : OK
  -- Functype_ok: |- functype : OK
	\end{lcverbatim}
}

\subsection{Subtyping}
##{relation: Functype_sub}
##{relation: Externtype_sub}
Name the two relations \K{Functype\_sub}, and \K{Externtype\_sub}. \\
Use \K{<:} to indicate subtype. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
relation Functype_sub: |- functype <: functype
relation Externtype_sub: |- externtype <: externtype
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Functype\_sub}}
##{rule+: Functype_sub}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Functype_sub:
  |- ft <: ft
	\end{lcverbatim}
}
  
\subsubsection{\normalfont\normalsize\textsc {Externtype\_sub-func}}
##{rule+: Externtype_sub/func}
Premise of $[\textsc{\scriptsize Externtype\_sub{-}func}]$ comes from relation \K{Functype\_sub}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Externtype_sub/func:
  |- FUNC ft_1 <: FUNC ft_2
  -- Functype_sub: |- ft_1 <: ft_2
	\end{lcverbatim}
}

\subsection{Instructions}
##{relation: Instr_ok}
##{relation: Instrs_ok}
##{relation: Expr_ok}
Name the three relations \K{Instr\_ok}, \K{Instrs\_ok}, and \K{Expr\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
relation Instr_ok: context |- instr : functype
relation Instrs_ok: context |- instr* : functype
relation Expr_ok: context |- expr : resulttype
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Expr\_ok}}
##{rule+: Expr_ok}
Premise of $[\textsc{\scriptsize Expr\_ok}]$ comes from relation \K{Instrs\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Expr_ok:
  C |- instr* : t?
  -- Instrs_ok: C |- instr* : eps -> t?
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instrs\_ok-empty}}
##{rule+: Instrs_ok/empty}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instrs_ok/empty:
  C |- eps : eps -> eps
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instrs\_ok-seq}}
##{rule+: Instrs_ok/seq}
Premises of $[\textsc{\scriptsize Instrs\_ok{-}seq}]$ come from relation \K{Instr\_ok} and \K{Instrs\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instrs_ok/seq:
  C |- instr_1 instr_2* : t_1* -> t_3*
  -- Instr_ok: C |- instr_1 : t_1* -> t_2*
  -- Instrs_ok: C |- instr_2 : t_2* -> t_3*
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instrs\_ok-frame}}
##{rule+: Instrs_ok/frame}
Premise of $[\textsc{\scriptsize Instrs\_ok{-}frame}]$ comes from relation \K{Instrs\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instrs_ok/frame:
  C |- instr* : t* t_1* -> t* t_2*
  -- Instrs_ok: C |- instr* : t_1* -> t_2*
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-nop}}
##{rule+: Instr_ok/nop}
Use \K{eps} to indicate an empty instruction sequence. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/nop:
  C |- NOP : eps -> eps
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-drop}}
##{rule+: Instr_ok/drop}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/drop:
  C |- DROP : t -> eps
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-select}}
##{rule+: Instr_ok/select}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/select:
  C |- SELECT : t t I32 -> t
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-block}}
##{rule+: Instr_ok/block}
Premise of $[\textsc{\scriptsize Instr\_ok{-}block}]$ comes from relation \K{Instrs\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/block:
  C |- BLOCK (eps -> t?) instr* : eps -> t?
  -- Instrs_ok: C, LABELS (t?) |- instr* : eps -> t?
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-loop}}
##{rule+: Instr_ok/loop}
Premise of $[\textsc{\scriptsize Instr\_ok{-}loop}]$ comes from relation \K{Instrs\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/loop:
  C |- LOOP (eps -> t?) instr* : eps -> t?
  -- Instrs_ok: C, LABELS (eps) |- instr* : eps -> eps
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-if}}
##{rule+: Instr_ok/if}
Premises of $[\textsc{\scriptsize Instr\_ok{-}block}]$ come from relation \K{Instrs\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/if:
  C |- IF (eps -> t?) instr_1* ELSE instr_2* : I32 -> t?
  -- Instrs_ok: C, LABELS (t?) |- instr_1* : eps -> t?
  -- Instrs_ok: C, LABELS (t?) |- instr_2* : eps -> t?
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-br}}
##{rule+: Instr_ok/br}
Write like below to indicate a condition:
\begin{lcverbatim}
rule Instr_ok/br:
  <content_of_rule>
  -- if <condition>
\end{lcverbatim}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/br:
  C |- BR l : t_1* t? -> t_2*
  -- if C.LABELS[l] = t?
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-br\_if}}
##{rule+: Instr_ok/br_if}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/br_if:
  C |- BR_IF l : t? I32 -> t?
  -- if C.LABELS[l] = t?
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-call}}
##{rule+: Instr_ok/call}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/call:
  C |- CALL x : t_1* -> t_2?
  -- if C.FUNCS[x] = t_1* -> t_2?
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-return}}
##{rule+: Instr_ok/return}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/return:
  C |- RETURN : t_1* t? -> t_2*
  -- if C.RETURN = t?
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-const}}
##{rule+: Instr_ok/const}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/const:
  C |- CONST t c_t : eps -> t
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-binop}}
##{rule+: Instr_ok/binop}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/binop:
  C |- BINOP t binop_t : t t -> t
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-local.get}}
##{rule+: Instr_ok/local.get}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/local.get:
  C |- LOCAL.GET x : eps -> t
  -- if C.LOCALS[x] = t
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_ok-local.set}}
##{rule+: Instr_ok/local.set}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_ok/local.set:
  C |- LOCAL.SET x : t -> eps
  -- if C.LOCALS[x] = t
	\end{lcverbatim}
}

\subsection{Constant Expressions}
##{relation: Instr_const}
##{relation: Expr_const}
##{relation: Expr_ok_const}
Name the three relations \K{Instr\_const}, \K{Expr\_const}, and \K{Expr\_ok\_const}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
relation Instr_const: context |- instr CONST
relation Expr_const: context |- expr CONST
relation Expr_ok_const: context |- expr : valtype? CONST
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Instr\_const-const}}
##{rule+: Instr_const/const}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Instr_const/const:
  C |- (CONST t c) CONST
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Expr\_const}}
##{rule+: Expr_const}
Premise of $[\textsc{\scriptsize Expr\_const}]$ is a sequence of premise, each one of which comes from relation \K{Instr\_const}. \\
To indicate a sequence of premise, group a single premise by \K{(} and \K{)}, then use \K{*} . \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Expr_const:
  C |- instr* CONST
  -- (Instr_const: C |- instr CONST)*
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Expr\_ok\_const}}
##{rule+: Expr_ok_const}
Premises of $[\textsc{\scriptsize Expr\_ok\_const}]$ come from relation \K{Expr\_ok} and \K{Expr\_const}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Expr_ok_const:
  C |- expr : t? CONST
  -- Expr_ok: C |- expr : t?
  -- Expr_const: C |- expr CONST
	\end{lcverbatim}
}

\subsection{Modules}
##{relation: Type_ok}
##{relation: Func_ok}
##{relation: Export_ok}
##{relation: Externidx_ok}
##{relation: Module_ok}
Name the five relations \K{Type\_ok}, \K{Func\_ok}, \K{Export\_ok}, \K{Externidx\_ok}, and \K{Module\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
relation Type_ok: |- type : functype
relation Func_ok: context |- func : functype
relation Export_ok: context |- export : externtype
relation Externidx_ok: context |- externidx : externtype
relation Module_ok: |- module : OK
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Type\_ok}}
##{rule+: Type_ok}
Premise of $[\textsc{\scriptsize Type\_ok}]$ comes from relation \K{Functype\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Type_ok:
  |- TYPE ft : ft
  -- Functype_ok: |- ft : OK
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Func\_ok}}
##{rule+: Func_ok}
The second premise of $[\textsc{\scriptsize Func\_ok}]$ comes from relation \K{Expr\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Func_ok:
  C |- FUNC x (LOCAL t)* expr : t_1* -> t_2?
  -- if C.TYPES[x] = t_1* -> t_2?
  -- Expr_ok: C, LOCALS t_1* t*, LABELS (t_2?), RETURN (t_2?) |- expr : t_2?
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Export\_ok}}
##{rule+: Export_ok}
Premise of $[\textsc{\scriptsize Export\_ok}]$ comes from relation \K{Externidx\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Export_ok:
  C |- EXPORT name externidx : xt
  -- Externidx_ok: C |- externidx : xt
	\end{lcverbatim}
}
  
\subsubsection{\normalfont\normalsize\textsc {Externidx\_ok-func}}
##{rule+: Externidx_ok/func}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Externidx_ok/func:
  C |- FUNC x : FUNC ft
  -- if C.FUNCS[x] = ft
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Module\_ok}}
##{rule+: Module_ok}
The first premise of $[\textsc{\scriptsize Module\_ok}]$ is a sequence of premise, each one of which comes from relation \K{Type\_ok}. \\
The second premise of $[\textsc{\scriptsize Module\_ok}]$ is a sequence of premise, each one of which comes from relation \K{Func\_ok}. \\
The third premise of $[\textsc{\scriptsize Module\_ok}]$ is a sequence of premise, each one of which comes from relation \K{Export\_ok}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Module_ok:
  |- MODULE type* func* export* : OK
  -- (Type_ok: |- type : ft')*
  -- (Func_ok: C |- func : ft)*
  -- (Export_ok: C |- export : xt)*
  -- if C = {TYPES ft'*, FUNCS ift* ft*}
	\end{lcverbatim}
}

\section{Reduction Rules}
Now, let's write the reduction rules for the instructions. Refer to Appendix A-4 for a full version. \\
Make a new file \K{4-reduction.wastup} and write on it.
%\begin{lcverbatim}
%relation Step: config ~> config
%\end{lcverbatim}
%It means that \K{rule}s of \K{relation Step} receives \K{config} as its input and then yields new \K{config} as its output. Here, \K{config} is defined in file \K{4-runtime.watsup}:
%\begin{lcverbatim}
%syntax config = state; admininstr*
%syntax admininstr =
%  | instr
%  | CALL_ADDR funcaddr
%  | LABEL_ n `{instr*} admininstr*
%  | FRAME_ n `{frame} admininstr*
%  | TRAP
%\end{lcverbatim}
%As you can see, \K{config} is a pair of \K{state} and sequence of \K{admininstr}. \K{admininstr} is a superset of \K{instr}, which contains some additional administrative instructions.\\ Declaring reduction rule in Wasm-DSL is basically done like this:
%\begin{lcverbatim}
%rule Step/<rule name>:
%  <input state>; <input instructions>  ~>  <output state>; <output instructions>
%  -- if <condition>
%  ...
%  -- if <condition>
%\end{lcverbatim}
%This means that if every \K{condition} is satisfied, then the state and instructions from stack is reduced to the right hand side. There may be no conditions. \\
%Now we'll declare each of the reduction rules one by one.

\subsection{Relations}
##{relation: Step}
##{relation: Step_pure}
##{relation: Step_read}
##{relation: Steps}
##{rule+: {Step/pure Step/read Steps/refl Steps/trans}}
Name the four relations \K{Step}, \K{Step\_pure}, \K{Step\_read}, and \K{Steps}. \\
Premise of $[\textsc{\scriptsize Step{-}pure}]$ comes from relation \K{Step\_pure}. \\
Premise of $[\textsc{\scriptsize Step{-}read}]$ comes from relation \K{Step\_read}. \\
Premise of $[\textsc{\scriptsize Step{-}trans}]$ comes from relation \K{Step} and \K{Steps}. \\
Use \K{~>} to indicate a reduction. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
relation Step: config ~> config
relation Step_pure: admininstr* ~> admininstr*
relation Step_read: config ~> admininstr*
relation Steps: config ~>* config

rule Step/pure:
  z; instr*  ~>  z; instr'*
  -- Step_pure: instr* ~> instr'*

rule Step/read:
  z; instr*  ~>  z; instr'*
  -- Step_read: z; instr* ~> instr'*

rule Steps/refl:
  z; admininstr* ~>* z; admininstr*

rule Steps/trans:
  z; admininstr*  ~>*  z''; admininstr''*
  -- Step: z; admininstr*  ~>  z'; admininstr'*
  -- Steps: z'; admininstr'  ~>*  z''; admininstr''*
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure-nop}}
##{rule+: Step_pure/nop}
%Use metavariable \K{z} for a \K{state}. \\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/nop:
  NOP  ~>  eps
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure-drop}}
##{rule+: Step_pure/drop}
%Use following syatax \K{val}, which is defined in \K{4-runtime.watsup}:
%\begin{lcverbatim}
%syntax val = CONST valtype val_(valtype)
%\end{lcverbatim}
as a variable. \\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/drop:
  val DROP  ~>  eps
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure{-}select}}
##{rule+: Step_pure/select-*}
When we get \K{SELECT} from stack, we have two cases: condition is true or false. \\
Define each of the case as seperate rule as follows:
\begin{lcverbatim}
rule Step_pure/select-true:
  ...

rule Step_pure/select-false:
  ...
\end{lcverbatim}
Write like \K{val\_1}, \K{val\_2} (and so on) to distinguish multiple \K{val}s. \\
Use \K{=/=} and \K{=} for integer comparison.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/select-true:
  val_1 val_2 (CONST I32 c) SELECT  ~>  val_1
  -- if c =/= 0

rule Step_pure/select-false:
  val_1 val_2 (CONST I32 c) SELECT  ~>  val_2
  -- if c = 0
	\end{lcverbatim}
	As you can see here, you can distinguish multiple metavariables with same type by adding \K{\_1}, \K{\_2} (and so on) after the metavariable name.
	Also, the names of two rules should be the same before hyphen (-), so that they can be treated as the same reduction rule.
}

\subsection{\normalfont\normalsize\textsc {Step\_read{-}block}}
##{rule+: Step_read/block}
Use \K{/\symbol{92}} and \K{\symbol{92}/} for logical and/or.
%To indicate a label, refer to following syntax:
%\begin{lcverbatim}
%LABEL_ n `{instr*} admininstr*
%\end{lcverbatim}
$\\$
{\color{red}
	Answer:
%	\begin{lcverbatim}
%rule Step/block-eps:
%  z; (BLOCK eps instr*)  ~>  z; (LABEL_ 0 `{eps} instr*)
%rule Step/block-val:
%  z; (BLOCK t instr*)  ~>  z; (LABEL_ 1 `{eps} instr*)
%	\end{lcverbatim}
%	Here, you may combine them by using \K{/\symbol{92}} for `and', \K{\symbol{92}/} for `or', and \K{?} for an optional argument:
	\begin{lcverbatim}
rule Step_pure/block:
  (BLOCK t? instr*)  ~>  (LABEL_ n `{eps} instr*)
  -- if t? = eps /\ n = 0 \/ t? =/= eps /\ n = 1
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_read{-}loop}}
##{rule+: Step_read/loop}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/loop:
  (LOOP t? instr*)  ~>  (LABEL_ 0 `{LOOP t? instr*} instr*)
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure{-}if}}
##{rule+: Step_pure/if-*}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/if-true:
  (CONST I32 c) (IF t? instr_1* ELSE instr_2*)  ~>   (BLOCK t? instr_1*)
  -- if c =/= 0

rule Step_pure/if-false:
  (CONST I32 c) (IF t? instr_1* ELSE instr_2*)  ~>   (BLOCK t? instr_2*)
  -- if c = 0
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure{-}br}}
##{rule+: Step_pure/br-*}
For arithmetic expressions, you should write like \K{\$(l+1)}, instead of \K{l+1}.\\
Use \K{\^} for a sequence with given length. e.g. \K{instr}\K{\^}\K{n}. \\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/br-zero:
  (LABEL_ n `{instr'*} val'* val^n (BR 0) instr*)  ~>  val^n instr'*

rule Step_pure/br-succ:
  (LABEL_ n `{instr'*} val* (BR $(l+1)) instr*)  ~>  val* (BR l)
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure{-}br\_if}}
##{rule+: Step_pure/br_if-*}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/br_if-true:
  (CONST I32 c) (BR_IF l)  ~>  (BR l)
  -- if c =/= 0

rule Step_pure/br_if-false:
  (CONST I32 c) (BR_IF l)  ~>  eps
  -- if c = 0
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_read{-}call}}
##{rule+: Step_read/call}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_read/call:
  z; val^k (CALL x)  ~>  (FRAME_ n `{f} (LABEL_ n `{eps} instr*))
  -- if a = $funcaddr(z)[x]
  -- if $funcinst(z)[a] = {TYPE (t_1^k -> t_2^n), MODULE mm, CODE func}
  -- if func = FUNC x (LOCAL t)* instr*
  -- if f = {LOCALS val^k ($default_(t))*, MODULE mm}
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure{-}frame{-}vals}}
##{rule+: Step_pure/frame-vals}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/frame-vals:
  (FRAME_ n `{f} val^n)  ~>  val^n
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure{-}return}}
##{rule+: Step_pure/return-*}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/return-frame:
  (FRAME_ n `{f} val'* val^n RETURN instr*)  ~>  val^n

rule Step_pure/return-label:
  (LABEL_ n `{instr'*} val* RETURN instr*)  ~>  val* RETURN
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure{-}trap}}
##{rule+: Step_pure/trap-*}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/trap-vals:
  val* TRAP instr*  ~>  TRAP
  -- if val* =/= eps \/ instr* =/= eps

rule Step_pure/trap-label:
  (LABEL_ n `{instr'*} TRAP)  ~>  TRAP

rule Step_pure/trap-frame:
  (FRAME_ n `{f} TRAP)  ~>  TRAP
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step{-}ctxt}}
##{rule+: Step/ctxt-*}
Premise of $[\textsc{\scriptsize Step{-}ctxt{-}label}]$ comes from relation \K{Step}. \\
Premise of $[\textsc{\scriptsize Step{-}ctxt{-}frame}]$ comes from relation \K{Step}. \\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/ctxt-label:
  z; (LABEL_ n `{instr_0*} instr*)  ~>  z'; (LABEL_ n `{instr_0*} instr'*)
  -- Step: z; instr* ~> z'; instr'*

rule Step/ctxt-frame:
  s; f; (FRAME_ n `{f'} instr*)  ~>  s'; f; (FRAME_ n `{f'} instr'*)
  -- Step: s; f'; instr* ~> s'; f'; instr'*
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_pure{-}binop}}
\subsubsection{$\mathrm{iadd}$, $\mathrm{isub}$, $\mathrm{imul}$, $\mathrm{idiv}$}
##{definition: iadd isub imul idiv}
Use \K{\symbol{92}} to indicate modular calculation. \\
Hint: The type declaration of functions \K{iadd}, \K{isub}, \K{imul}, and \K{idiv} is as follows:
\begin{lcverbatim}
def $iadd(N, iN(N), iN(N)) : iN(N)
def $isub(N, iN(N), iN(N)) : iN(N)
def $imul(N, iN(N), iN(N)) : iN(N)
def $idiv(N, iN(N), iN(N)) : iN(N)*
\end{lcverbatim}
{\color{red}
	Answer:
	\begin{lcverbatim}
def $iadd(N, iN(N), iN(N)) : iN(N)
def $isub(N, iN(N), iN(N)) : iN(N)
def $imul(N, iN(N), iN(N)) : iN(N)
def $idiv(N, iN(N), iN(N)) : iN(N)*
def $iadd(N, c_1, c_2) = $((c_1 + c_2) \ 2^N)
def $isub(N, c_1, c_2) = $((c_1 - c_2 + 2^N) \ 2^N)
def $imul(N, c_1, c_2) = $((c_1 * c_2) \ 2^N)
def $idiv(N, c_1, 0) = eps
def $idiv(N, c_1, c_2) = $(c_1 / c_2)
	\end{lcverbatim}
}

\subsubsection{$\mathrm{binop}$}
##{definition: binop}
Hint: The type declaration of function \K{binop} is as follows:
\begin{lcverbatim}
def $binop(valtype, binop, num_(valtype), num_(valtype)) : num_(valtype)*
\end{lcverbatim}
{\color{red}
	Answer:
	\begin{lcverbatim}
def $binop(valtype, binop, num_(valtype), num_(valtype)) : num_(valtype)*

def $binop(t, ADD, c_1, c_2) = $iadd($size(t), c_1, c_2)
def $binop(t, SUB, c_1, c_2) = $isub($size(t), c_1, c_2)
def $binop(t, MUL, c_1, c_2) = $imul($size(t), c_1, c_2)
def $binop(t, DIV, c_1, c_2) = $idiv($size(t), c_1, c_2)
	\end{lcverbatim}
}

\subsubsection{\normalfont\normalsize\textsc {Step\_pure{-}binop}}
##{rule+: Step_pure/binop-*}
%When we get \K{BINOP} from stack, there are three cases for \K{binop\_(valtype)}: \K{ADD}, \K{SUB}, \K{MUL}. \\
%Define each of the case as seperate rule, and use built-in functions \K{iadd}, \K{isub}, \K{imul} as follows:
%\begin{lcverbatim}
%def $iadd(N, iN(N), iN(N)) : iN(N)
%def $isub(N, iN(N), iN(N)) : iN(N)
%def $imul(N, iN(N), iN(N)) : iN(N)
%def $iadd(N, c_1, c_2) = $((c_1 + c_2) \ 2^N)
%def $isub(N, c_1, c_2) = $((c_1 - c_2) \ 2^N)
%def $imul(N, c_1, c_2) = $((c_1 * c_2) \ 2^N)
%
%rule Step/binop-add:
%  ...
%
%rule Step/binop-sub:
%  ...
%
%rule Step/binop-mul:
%  ...
%\end{lcverbatim}
%Use function \K{size}, which is defined from subsection 4.1.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_pure/binop-val:
  (CONST t c_1) (CONST t c_2) (BINOP t binop)  ~>  (CONST t c)
  -- if $binop(t, binop, c_1, c_2) = c

rule Step_pure/binop-trap:
  (CONST t c_1) (CONST t c_2) (BINOP t binop)  ~>  TRAP
  -- if $binop(t, binop, c_1, c_2) = eps
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step\_read{-}local.get}}
##{rule+: Step_read/local.get}
%To get a local value from \K{state z} and \K{idx x}, write \K{\$local(z, x)}.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step_read/local.get:
  z; (LOCAL.GET x)  ~>  $local(z, x)
	\end{lcverbatim}
}

\subsection{\normalfont\normalsize\textsc {Step{-}local.set}}
##{rule+: Step/local.set}
%To get a new state which is exactly same with \K{state z} except that its local value with \K{idx x} is \K{val v}, write \K{\$with\_local(z, x, v)}.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/local.set:
  z; val (LOCAL.SET x)  ~>  $with_local(z, x, val); eps
	\end{lcverbatim}
}

\appendix
\section{Appendix}
\subsection{Basic Syntax}
##{syntax+: {N n}}
##{syntax+: {iN}}
##{syntax+: {char name}}
##{syntax+: idx {typeidx funcidx labelidx localidx}}
##{syntax+: valtype}
##{syntax+: functype}
##{syntax+: externtype}
##{definition: size}
##{syntax+: num_}
##{syntax+: binop}
##{syntax+: instr}
##{syntax+: expr}
##{syntax+: {type local func externidx export module}}

\subsection{Runtime-Related Syntax}
##{syntax+: {addr funcaddr}}
##{syntax+: val}
##{syntax+: externval}
##{syntax+: {funcinst exportinst moduleinst}}
##{syntax+: {store frame state config}}
##{syntax+: admininstr}
##{definition: funcaddr}
##{definition: local}
##{definition: with_local}
##{definition: funcinst}
##{definition: default_}
##{syntax+: context}

\subsection{Context, Validation Rules}
##{relation: Functype_ok}
##{relation: Externtype_ok}
##{rule+: Functype_ok}
##{rule+: Externtype_ok/func}
##{relation: Functype_sub}
##{relation: Externtype_sub}
##{rule+: Functype_sub}
##{rule+: Externtype_sub/func}
##{relation: Instr_ok}
##{relation: Instrs_ok}
##{relation: Expr_ok}
##{rule+: Expr_ok}
##{rule+: Instrs_ok/empty}
##{rule+: Instrs_ok/seq}
##{rule+: Instrs_ok/frame}
##{rule+: Instr_ok/nop}
##{rule+: Instr_ok/drop}
##{rule+: Instr_ok/select}
##{rule+: Instr_ok/block}
##{rule+: Instr_ok/loop}
##{rule+: Instr_ok/if}
##{rule+: Instr_ok/br}
##{rule+: Instr_ok/br_if}
##{rule+: Instr_ok/call}
##{rule+: Instr_ok/return}
##{rule+: Instr_ok/const}
##{rule+: Instr_ok/binop}
##{rule+: Instr_ok/local.get}
##{rule+: Instr_ok/local.set}
##{relation: Instr_const}
##{relation: Expr_const}
##{relation: Expr_ok_const}
##{rule+: Instr_const/const}
##{rule+: Expr_const}
##{rule+: Expr_ok_const}
##{relation: Type_ok}
##{relation: Func_ok}
##{relation: Export_ok}
##{relation: Externidx_ok}
##{relation: Module_ok}
##{rule+: Type_ok}
##{rule+: Func_ok}
##{rule+: Export_ok}
##{rule+: Externidx_ok/func}
##{rule+: Module_ok}

\subsection{Reduction Rules}
##{relation: Step}
##{relation: Step_pure}
##{relation: Step_read}
##{relation: Steps}
##{rule+: {Step/pure Step/read Steps/refl Steps/trans}}
##{rule+: Step_pure/nop}
##{rule+: Step_pure/drop}
##{rule+: Step_pure/select-*}
##{rule+: Step_read/block}
##{rule+: Step_read/loop}
##{rule+: Step_pure/if-*}
##{rule+: Step_pure/br-*}
##{rule+: Step_pure/br_if-*}
##{rule+: Step_read/call}
##{rule+: Step_pure/frame-vals}
##{rule+: Step_pure/return-*}
##{rule+: Step_pure/trap-*}
##{rule+: Step/ctxt-*}
##{definition: iadd isub imul idiv}
##{definition: binop}
##{rule+: Step_pure/binop-*}
##{rule+: Step_read/local.get}
##{rule+: Step/local.set}

\end{document}
