\documentclass{article}
\usepackage{fullpage,fancyvrb,newverbs,xcolor,amsfonts}

\definecolor{cverbbg}{gray}{0.93}

\newenvironment{cverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{cverbbg}{\BUseVerbatim{cverb}}%
  \endflushleft
}
\newenvironment{lcverbatim}
 {\SaveVerbatim{cverb}}
 {\endSaveVerbatim
  \flushleft\fboxrule=0pt\fboxsep=.5em
  \colorbox{cverbbg}{%
    \makebox[\dimexpr\linewidth-2\fboxsep][l]{\BUseVerbatim{cverb}}%
  }
  \endflushleft
}

\newcommand{\ctexttt}[1]{\colorbox{cverbbg}{\texttt{#1}}}
\newverbcommand{\cverb}
  {\setbox\verbbox\hbox\bgroup}
  {\egroup\colorbox{cverbbg}{\box\verbbox}}


\newcommand\X[1]{\mathit{#1}}
\newcommand\K[1]{\texttt{#1}}

\date{}

\begin{document}
\title{Mini-Wasm Tutorial}
\maketitle

\section{Introduction}
In this tutorial, we will practice how to write a spec in Wasm-DSL.
Here, instead of a full Wasm, a very simplified version of Wasm (which we call Mini-Wasm) is used as our goal.

\subsection{Abstract Syntax of Mini-Wasm}
Abstract syntax of Mini-Wasm is as follows:
%\[
%\begin{array}{rrl}
%\X{module} & ::= & \K{module}\ \X{type}^*\ \X{func}^*\ \X{start}^*\ \X{export}^*\\
%\X{type} & ::= & \K{type}\ \X{type}_{\X{func}}\\ 
%\X{code} & ::= & \X{local}^*\ \X{instr}^*\\
%\X{local} & ::= & \K{local}\ \X{type}_{\X{val}}\\\
%\X{func} & ::= & \K{func}\ \X{idx}_{\X{type}}\ \X{code}\\
%\X{start} & ::= & \K{start}\ \X{idx}_{\X{func}}\\
%\X{export} & ::= & \K{export}\ \mbox{``}\K{name}\mbox{''}\ (\K{func}\ \X{idx}_{\X{func}})\\
%\X{instr} & ::= & \K{nop}~\mid~\K{drop}~\mid~\K{select}~\mid~
%\X{type}_{\X{val}}\K{.const}\ \X{value}\K{\_}(\X{type}_{\X{val}})~\mid~
%\X{binop}\\
%&\mid&(\K{get}\mid\K{set}\mid\K{tee})\K{\_}\K{local}\ \X{idx}_{\X{local}}~\mid~
%\K{call}\ \X{idx}_{\X{func}}~\mid~\K{return}\\
%&\mid&\K{block}\ \X{valtype?}\ \X{instr}^*~\mid~\K{loop}\ \X{valtype?}\ \X{instr}^*\\
%&\mid&\K{if}\ \X{valtype?}\ \X{instr}^*\ \K{else}\ \X{instr}^*~\mid~\K{br}\ \X{idx}_{\X{label}}~\mid~\K{br\_if}\ \X{idx}_{\X{label}}\\
%\X{binop} & ::= & \K{i32.add}~\mid~\K{i32.sub}~\mid~\K{i32.mul}~\mid~
%\K{i64.add}~\mid~\K{i64.sub}~\mid~\K{i64.mul}\\
%\X{type}_{\X{val}} & ::= & \K{i32}~\mid~\K{i64}\\
%\X{type}_{\X{func}} & ::= & \X{type}_{\X{val}}^*\rightarrow \X{type}_{\X{val}}^*\\
%\X{idx}_{\X{type}|\X{func}|\X{local}|\X{label}} & \in & [0,\ 2^{32} - 1]\\
%\X{value}\K{\_}(\X{i32}) & \in & [0,\ 2^{32} - 1]\\
%\X{value}\K{\_}(\X{i64}) & \in & [0,\ 2^{64} - 1]\\
%\end{array}
%\]

$$
\begin{array}{@{}lrrl@{}l@{}}
	& N &::=& \mathbb{N} \\
	& n &::=& \mathbb{N} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(integer)} & {i}{N} &::=& 0 ~|~ \dots ~|~ {2^{N}} - 1 \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(character)} & {\mathit{char}} &::=& \mathrm{U{+}00} ~|~ \dots ~|~ \mathrm{U{+}D7FF} ~|~ \mathrm{U{+}E000} ~|~ \dots ~|~ \mathrm{U{+}10FFFF} \\
	\mbox{(name)} & {\mathit{name}} &::=& {{\mathit{char}}^\ast} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(index)} & {\mathit{idx}} &::=& {i}{32} \\
	\mbox{(type index)} & {\mathit{typeidx}} &::=& {\mathit{idx}} \\
	\mbox{(function index)} & {\mathit{funcidx}} &::=& {\mathit{idx}} \\
	\mbox{(label index)} & {\mathit{labelidx}} &::=& {\mathit{idx}} \\
	\mbox{(local index)} & {\mathit{localidx}} &::=& {\mathit{idx}} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(number type)} & {\mathit{valtype}} &::=& \mathsf{i{\scriptstyle 32}} ~|~ \mathsf{i{\scriptstyle 64}} \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(result type)} & {\mathit{resulttype}} &::=& {{\mathit{valtype}}^?} \\
	\mbox{(function type)} & {\mathit{functype}} &::=& {{\mathit{valtype}}^\ast} \rightarrow {{\mathit{valtype}}^\ast} \\
	\mbox{(external type)} & {\mathit{externtype}} &::=& \mathsf{func}~{\mathit{functype}} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	& {{\mathit{num}}}_{{\mathit{valtype}}} &::=& {i}{{|{\mathit{valtype}}|}} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	& {\mathit{binop}} &::=& \mathsf{add} ~|~ \mathsf{sub} ~|~ \mathsf{mul} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(instruction)} & {\mathit{instr}} &::=& \mathsf{nop} \\ &&|&
	\mathsf{drop} \\ &&|&
	\mathsf{select} \\ &&|&
	\mathsf{block}~{\mathit{functype}}~{{\mathit{instr}}^\ast} \\ &&|&
	\mathsf{loop}~{\mathit{functype}}~{{\mathit{instr}}^\ast} \\ &&|&
	\mathsf{if}~{\mathit{functype}}~{{\mathit{instr}}^\ast}~\mathsf{else}~{{\mathit{instr}}^\ast} \\ &&|&
	\mathsf{br}~{\mathit{labelidx}} \\ &&|&
	\mathsf{br\_if}~{\mathit{labelidx}} \\ &&|&
	\mathsf{call}~{\mathit{funcidx}} \\ &&|&
	\mathsf{return} \\ &&|&
	{\mathit{valtype}}{.}\mathsf{const}~{{\mathit{num}}}_{{\mathit{valtype}}} \\ &&|&
	{\mathit{valtype}} {.} {\mathit{binop}} \\ &&|&
	\mathsf{local.get}~{\mathit{localidx}} \\ &&|&
	\mathsf{local.set}~{\mathit{localidx}} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(expression)} & {\mathit{expr}} &::=& {{\mathit{instr}}^\ast} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(type)} & {\mathit{type}} &::=& \mathsf{type}~{\mathit{functype}} \\
	\mbox{(local)} & {\mathit{local}} &::=& \mathsf{local}~{\mathit{valtype}} \\
	\mbox{(function)} & {\mathit{func}} &::=& \mathsf{func}~{\mathit{typeidx}}~{{\mathit{local}}^\ast}~{\mathit{expr}} \\
	\mbox{(external index)} & {\mathit{externidx}} &::=& \mathsf{func}~{\mathit{funcidx}} \\
	\mbox{(export)} & {\mathit{export}} &::=& \mathsf{export}~{\mathit{name}}~{\mathit{externidx}} \\
	\mbox{(module)} & {\mathit{module}} &::=& \mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{export}}^\ast} \\
\end{array}
$$

\subsection{Working Directory}
The directory \K{<root>/spectec/tutorial} is where we will work on.

\subsection{How To Run}
Running \K{make} in \K{<root>/spectec} will yield an executable file \K{watsup} in same directory. You can use this to generate various types of spec. For example, in directory \K{<root>/spectec}:
\begin{lcverbatim}
./watsup ./tutorial/*.watsup --prose
\end{lcverbatim}
will generate prose, using every \K{./watsup} file in directory \K{./tutorial} as input. There are various options including \K{--interpreter}, \K{--latex}, or \K{--print-il}. You can see all possible options with command \K{./watsup -help}.

\section{Syntax}
Now, we will start from writing the syntax of Mini-Wasm.
Make a new file \K{1-syntax.wastup}.
Declaring syntax in Wasm-DSL is basically done like this:
\begin{lcverbatim}
syntax <name_of_syntax> = <case> | ... | <case>
\end{lcverbatim}
Use keyword \K{syntax}, write the name of syntax in lowercase, and simply list the possible cases with the separator \K{|}. Here, each of the case can be a nonterminal node (usually written in lowercases) which refers to another syntax, or a terminal node (usually written in uppercases).\\
We'll declare each of the syntax one by one.

\subsection{$N$, $n$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	& N &::=& \mathbb{N} \\
	& n &::=& \mathbb{N} \\
\end{array}
$$
This syntax is simply written in Wasm-DSL like this:
\begin{lcverbatim}
syntax N = nat
syntax n = nat
\end{lcverbatim}
Here, \K{nat} is a pre-defined syntax, which indicates any natural number.
This means the syntax \K{N} and \K{n} is a natural number.

\subsection{${i}{N}$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(integer)} & {i}{N} &::=& 0 ~|~ \dots ~|~ {2^{N}} - 1 \\
\end{array}
$$
Write as following:
\begin{lcverbatim}
syntax iN(N) = 0 | ... | 2^N-1
\end{lcverbatim}
Now, the syntax \K{iN} is declared in regard with parameter \K{N}. Also, you can use \K{...} to indicate a range.

\subsection{$char$, $name$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(character)} & {\mathit{char}} &::=& \mathrm{U{+}00} ~|~ \dots ~|~ \mathrm{U{+}D7FF} ~|~ \mathrm{U{+}E000} ~|~ \dots ~|~ \mathrm{U{+}10FFFF} \\
	\mbox{(name)} & {\mathit{name}} &::=& {{\mathit{char}}^\ast} \\
\end{array}
$$
We need a declaration of $name$, which indicates for a general string. We can declare a syntax for a character like this:
\begin{lcverbatim}
syntax char = U+0000 | ... | U+D7FF | U+E000 | ... | U+10FFFF
\end{lcverbatim}
This syntax is built-in, and denotes Unicode code points.
Now, \K{name} is simply an iteration of \K{char}s.
\begin{lcverbatim}
syntax name = char*
\end{lcverbatim}

\subsection{$idx$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(index)} & {\mathit{idx}} &::=& {i}{32} \\
	\mbox{(type index)} & {\mathit{typeidx}} &::=& {\mathit{idx}} \\
	\mbox{(function index)} & {\mathit{funcidx}} &::=& {\mathit{idx}} \\
	\mbox{(label index)} & {\mathit{labelidx}} &::=& {\mathit{idx}} \\
	\mbox{(local index)} & {\mathit{localidx}} &::=& {\mathit{idx}} \\
\end{array}
$$
You can use \K{...} to describe a range.
The Wasm-DSL version of upper syntax will be:
\begin{lcverbatim}
	syntax idx = 0 | ... | 2^32-1
\end{lcverbatim}
Since we have three types of index (which are semantically same, but syntactically different), write like this:
\begin{lcverbatim}
	syntax funcidx = idx
	syntax labelidx = idx
	syntax localidx = idx
\end{lcverbatim}

\subsection{$\mathit{valtype}$}
$$
\begin{array}{@{}lrrl@{}l@{}}
	\mbox{(number type)} & {\mathit{valtype}} &::=& \mathsf{i{\scriptstyle 32}} ~|~ \mathsf{i{\scriptstyle 64}} \\
\end{array}
$$
This syntax is simply written in Wasm-DSL like this:
\begin{lcverbatim}
syntax valtype = I32 | I64
\end{lcverbatim}
This means the syntax \K{valtype} is either \K{I32} or \K{I64}. Here, write terminal nodes \K{I32} and \K{I64} instead of \K{i32} and \K{i64}, and nonterminal node \K{valtype} instead of \K{VALTYPE}.

\subsection{$value$}
\[
\begin{array}{rrl}
\X{value}\K{\_}(\X{i32}) & \in & [0,\ 2^{32} - 1]\\
\X{value}\K{\_}(\X{i64}) & \in & [0,\ 2^{64} - 1]\\
\end{array}
\]
Here, the syntax $value\_$ is declared in regard with parameter \K{valtype}.
This can be done like this:
\begin{lcverbatim}
syntax val_(valtype)
syntax val_(I32) = 0 | ... | 2^32-1
syntax val_(I64) = 0 | ... | 2^64-1
\end{lcverbatim}
The type is defined differently for different parameters, by pattern-matching on the parameter.
Here we can declare a general range, by using parameter again.
\begin{lcverbatim}
syntax iN(N) = 0 | ... | 2^N-1
\end{lcverbatim}
Now, we can write \K{iN(32)} and \K{iN(64)} instead of \verb!0 | ... | 2^32-1! and \verb!0 | ... | 2^64-1!.
New declaration of \K{idx} and \K{val} is as follows:
\begin{lcverbatim}
syntax idx = iN(32)
syntax val(valtype)
syntax val(I32) = iN(32)
syntax val(I64) = iN(64)
\end{lcverbatim}

\subsection{$binop$}
\[
\begin{array}{rrl}
	\X{binop} & ::= & \K{i32.add}~\mid~\K{i32.sub}~\mid~\K{i32.mul}~\mid~
	\K{i64.add}~\mid~\K{i64.sub}~\mid~\K{i64.mul}\\
\end{array}
\]
We can declare two groups of \K{binop}, classifying them by one's parameter type:
\begin{lcverbatim}
syntax binop = ADD | SUB | MUL
\end{lcverbatim}

\subsection{$instr$}
\[
\begin{array}{rrl}
	\X{instr} & ::= & \K{nop}~\mid~\K{drop}~\mid~\K{select}~\mid~
	\X{type}_{\X{val}}\K{.const}\ \X{value}\K{\_}(\X{type}_{\X{val}})~\mid~
	\X{binop}\\
	&\mid&(\K{get}\mid\K{set})\K{\_}\K{local}\ \X{idx}_{\X{local}}~\mid~
	\K{call}\ \X{idx}_{\X{func}}~\mid~\K{return}~\mid~\K{block}\ \X{valtype?}\ \X{instr}^*\\
	&\mid&\K{loop}\ \X{valtype?}\ \X{instr}^*~\mid~\K{if}\ \X{valtype?}\ \X{instr}^*\ \K{else}\ \X{instr}^*~\mid~\K{br}\ \X{idx}_{\X{label}}~\mid~\K{br\_if}\ \X{idx}_{\X{label}}\\
\end{array}
\]
Use \K{*} to represent a sequence. Now we can fully write \K{instr} as follows:
\begin{lcverbatim}
syntax instr =
  | NOP
  | DROP
  | SELECT
  | CONST valtype val_(valtype)
  | BINOP valtype binop_(valtype)
  | LOCAL.GET localidx
  | LOCAL.SET localidx
  | CALL funcidx
  | RETURN
  | BLOCK valtype? instr*
  | LOOP valtype? instr*
  | IF valtype? instr* ELSE instr*
  | BR labelidx
  | BR_IF labelidx
\end{lcverbatim}

\subsection{$type_{func}$}
\[
\begin{array}{rrl}
\X{type}_{\X{func}} & ::= & \X{type}_{\X{val}}^*\rightarrow \X{type}_{\X{val}}^*\\
\end{array}
\]
We can use \K{->} to indicate a function:
\begin{lcverbatim}
syntax functype = valtype* -> valtype*
\end{lcverbatim}

\subsection{$module$}
\[
\begin{array}{rrl}
	\X{module} & ::= & \K{module}\ \X{type}^*\ \X{func}^*\ \X{start}^*\ \X{export}^*\\
	\X{type} & ::= & \K{type}\ \X{type}_{\X{func}}\\ 
	\X{code} & ::= & \X{local}^*\ \X{instr}^*\\
	\X{local} & ::= & \K{local}\ \X{type}_{\X{val}}\\\
	\X{func} & ::= & \K{func}\ \X{idx}_{\X{type}}\ \X{code}\\
	\X{start} & ::= & \K{start}\ \X{idx}_{\X{func}}\\
	\X{export} & ::= & \K{export}\ \mbox{``}\K{name}\mbox{''}\ (\K{func}\ \X{idx}_{\X{func}})\\
\end{array}
\]
Declare $module$ and its subcomponents as follows:
\begin{lcverbatim}
syntax module = MODULE type* func* start* export*
syntax type = TYPE functype
syntax code = local* instr*
syntax local = LOCAL valtype
syntax func = FUNC typeidx code
syntax start = START funcidx
syntax export = EXPORT name (FUNC funcidx)
\end{lcverbatim}

\section{Metavariables}
We're done with writing syntax of Mini-Wasm. Now, we will declare metavariables, which is used in reduction rules. \\
There are three ways to make use of metavariables.

\subsection{Explicit Declarartion}
\begin{lcverbatim}
var <name_of_var> : <type>
\end{lcverbatim}
We can explicitly declare a metavariable as above. Use keyword \K{var}, and give its name and type. Here, \K{<type>} may be a complex form, which contains iteration, parametric syntax, etc.\\
Declare variables in file \K{1-syntax.wastup} as follows:
\begin{lcverbatim}
var x : idx
var l : labelidx
var t : valtype
var ft : functype
var in : instr
var e : instr*
var ty : type
var loc : local
var ex : export
var st : start
\end{lcverbatim}

\subsection{Using Syntax Name}
Also, we can use the syntax name directly as a variable of same type. For example, instead of below code:
\begin{lcverbatim}
rule Step/example:
  z; (CONST t c_1) (CONST t c_2)  ~>  z; (CONST t c_1)
\end{lcverbatim}

we can write like this:
\begin{lcverbatim}
rule Step/example:
  z; (CONST valtype c_1) (CONST valtype c_2)  ~>  z; (CONST valtype c_1)
\end{lcverbatim}

\subsection{Using Without Declaration}
%\subsection{Implicit declaration? Infer? Using without declaration?}
Finally, we can use a metavariable without declaration in suitable situations. In this case, its type will be inferred. Now, we may rewrite the above rule as:
\begin{lcverbatim}
rule Step/example:
  z; (CONST anyname c_1) (CONST anyname c_2)  ~>  z; (CONST anyname c_1)
\end{lcverbatim}

\section{Functions}
\begin{lcverbatim}
def $<func_name>(<type_of_arg1>, <type_of_arg2>, ... , <type_of_argn>) : <result_type>
def $<func_name>(<arg1>, <arg2>, ... , <argn>) = <result>
\end{lcverbatim}
We can declare functions as above. The first line indicates the type of arguments and result of the function. The second line is function body, which describes how the actual result comes out.

\subsection{Declaring Function Body}
Function body can be multiple cases, which defines a function by pattern matching. \\
For example, we can define a function \K{size}, which returns the size of a \K{valtype} as:
\begin{lcverbatim}
def $size(valtype) : nat
def $size(I32) = 32
def $size(I64) = 64
\end{lcverbatim}
Now, the function \K{size} will return \K{32} for input \K{I32}, and \K{64} for input \K{I64}. \\
\\
We can also add condition to a function body. \\
For example, we can define a function \K{min}, which returns a smaller integer between two:
\begin{lcverbatim}
def $min(nat, nat) : nat
def $min(i, j) = i
  -- if i < j
def $min(i, j) = j
\end{lcverbatim}
Now, the function \K{min} will return \K{i} if \K{i < j}, else \K{j}.

%\subsection{Built-in Functions}
%Here are some built-in functions that we can use:
%\begin{lcverbatim}
%$ibytes
%$inverse_of_ibytes
%$nbytes
%$vbytes
%...
%\end{lcverbatim}
%You can find their definition from the file \K{<root>/spectec/src/backend-interpreter/numerics.ml}.
%Also, even though they are built-in, you should declare their type first, and use them in Wasm-DSL.
%
\subsection{Using Functions}
Functions can be used in definition of other functions or reduction rules. When using function, write as below form:
\begin{lcverbatim}
$<func_name>(<arg1>, <arg2>, ... , <argn>)
\end{lcverbatim}
For example,
\begin{lcverbatim}
$iadd(c_1, c_2)
\end{lcverbatim}
equals to the return value of function \K{iadd} with arguments \K{c\_1}, \K{c\_2}.

\section{Reduction Rules}
Now, let's write the reduction rules for the instructions.
First, make a new file \K{8-reduction.wastup} and write as follows:
\begin{lcverbatim}
relation Step: config ~> config
\end{lcverbatim}
It means that \K{rule}s of \K{relation Step} receives \K{config} as its input and then yields new \K{config} as its output. Here, \K{config} is defined in file \K{4-runtime.watsup}:
\begin{lcverbatim}
syntax config = state; admininstr*
syntax admininstr =
  | instr
  | CALL_ADDR funcaddr
  | LABEL_ n `{instr*} admininstr*
  | FRAME_ n `{frame} admininstr*
  | TRAP
\end{lcverbatim}
As you can see, \K{config} is a pair of \K{state} and sequence of \K{admininstr}. \K{admininstr} is a superset of \K{instr}, which contains some additional administrative instructions.\\ Declaring reduction rule in Wasm-DSL is basically done like this:
\begin{lcverbatim}
rule Step/<rule name>:
  <input state>; <input instructions>  ~>  <output state>; <output instructions>
  -- if <condition>
  ...
  -- if <condition>
\end{lcverbatim}
This means that if every \K{condition} is satisfied, then the state and instructions from stack is reduced to the right hand side. There may be no conditions. \\
Now we'll declare each of the reduction rules one by one.

\subsection{\K{NOP}}
%\K{NOP} means 'no operation', so if we get \K{NOP} from stack, we can just remove it from stack. \\
Use \K{eps} to indicate an empty instruction sequence. \\
Use metavariable \K{z} for a \K{state}. \\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/nop:
  z; NOP  ~>  z; eps
	\end{lcverbatim}
}

\subsection{\K{DROP}}
%If we get \K{DROP} from stack, then we should remove a value from stack. \\
Use following syatax \K{val}, which is defined in \K{4-runtime.watsup}:
\begin{lcverbatim}
syntax val = CONST valtype val_(valtype)
\end{lcverbatim}
as a variable. \\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/drop:
  z; val DROP  ~>  z; eps
	\end{lcverbatim}
}

\subsection{\K{SELECT}}
When we get \K{SELECT} from stack, we have two cases: condition is true or false. \\
Define each of the case as seperate rule as following:
\begin{lcverbatim}
rule Step/select-true:
  ...

rule Step/select-false:
  ...
\end{lcverbatim}
Write like \K{val\_1}, \K{val\_2} (and so on) to distinguish multiple \K{val}s. \\
Use \K{=/=} and \K{=} for integer comparison.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/select-true:
  z; val_1 val_2 (CONST I32 c) SELECT  ~>  z; val_1
  -- if c =/= 0

rule Step/select-false:
  z; val_1 val_2 (CONST I32 c) SELECT  ~>  z; val_2
  -- if c = 0
	\end{lcverbatim}
	As you can see here, you can distinguish multiple metavariables with same type by adding \K{\_1}, \K{\_2} (and so on) after the metavariable name.
	Also, the names of two rules should be the same before hyphen (-), so that they can be prosed as the same reduction rule.
}

\subsection{\K{BINOP}}
When we get \K{BINOP} from stack, there are three cases for \K{binop\_(valtype)}: \K{ADD}, \K{SUB}, \K{MUL}. \\
Define each of the case as seperate rule, and use built-in functions \K{iadd}, \K{isub}, \K{imul} as following:
\begin{lcverbatim}
def $iadd(N, iN(N), iN(N)) : iN(N)
def $isub(N, iN(N), iN(N)) : iN(N)
def $imul(N, iN(N), iN(N)) : iN(N)
def $iadd(N, c_1, c_2) = $((c_1 + c_2) \ 2^N)
def $isub(N, c_1, c_2) = $((c_1 - c_2) \ 2^N)
def $imul(N, c_1, c_2) = $((c_1 * c_2) \ 2^N)

rule Step/binop-add:
  ...

rule Step/binop-sub:
  ...

rule Step/binop-mul:
  ...
\end{lcverbatim}
Use function \K{size}, which is defined from subsection 4.1.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
def $iadd(N, iN(N), iN(N)) : iN(N)
def $isub(N, iN(N), iN(N)) : iN(N)
def $imul(N, iN(N), iN(N)) : iN(N)

rule Step/binop-add:
  z; (CONST t c_1) (CONST t c_2) (BINOP t ADD)  ~>  z; (CONST t c)
-- if $iadd($size(t), c_1, c_2) = c

rule Step/binop-sub:
z; (CONST t c_1) (CONST t c_2) (BINOP t SUB)  ~>  z; (CONST t c)
-- if $isub($size(t), c_1, c_2) = c

rule Step/binop-mul:
z; (CONST t c_1) (CONST t c_2) (BINOP t MUL)  ~>  z; (CONST t c)
-- if $imul($size(t), c_1, c_2) = c
	\end{lcverbatim}
	Now, we may combine them by declaring a new function \K{binop} as follows:
	\begin{lcverbatim}
def $iadd(N, iN(N), iN(N)) : iN(N)
def $isub(N, iN(N), iN(N)) : iN(N)
def $imul(N, iN(N), iN(N)) : iN(N)

def $binop(valtype, binop_(valtype), val_(valtype), val_(valtype)) : val_(valtype)*
def $binop(t, ADD, c_1, c_2) = $iadd($size(t), c_1, c_2)
def $binop(t, SUB, c_1, c_2) = $isub($size(t), c_1, c_2)
def $binop(t, MUL, c_1, c_2) = $imul($size(t), c_1, c_2)

rule Step/binop:
  z; (CONST t c_1) (CONST t c_2) (BINOP t binop)  ~>  z; (CONST t c)
  -- if $binop(t, binop, c_1, c_2) = c
	\end{lcverbatim}
}

\subsection{\K{BLOCK}}
To indicate a label, refer to following syntax:
\begin{lcverbatim}
LABEL_ n `{instr*} admininstr*
\end{lcverbatim}
$\\$
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/block-eps:
  z; (BLOCK eps instr*)  ~>  z; (LABEL_ 0 `{eps} instr*)
rule Step/block-val:
  z; (BLOCK t instr*)  ~>  z; (LABEL_ 1 `{eps} instr*)
	\end{lcverbatim}
	Here, you may combine them by using \K{/\symbol{92}} for `and', \K{\symbol{92}/} for `or', and \K{?} for an optional argument:
	\begin{lcverbatim}
rule Step/block:
  z; (BLOCK t? instr*)  ~>  z; (LABEL_ n `{eps} instr*)
  -- if t? = eps /\ n = 0 \/ t? =/= eps /\ n = 1
	\end{lcverbatim}
}

\subsection{\K{LOOP}}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/loop:
  z; (LOOP t? instr*)  ~>  z; (LABEL_ 0 `{LOOP t? instr*} instr*)
	\end{lcverbatim}
}

\subsection{\K{IF}}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/if-true:
z; (CONST I32 c) (IF t? instr_1* ELSE instr_2*)  ~>  z; (BLOCK t? instr_1*)
-- if c =/= 0

rule Step/if-false:
z; (CONST I32 c) (IF t? instr_1* ELSE instr_2*)  ~>  z; (BLOCK t? instr_2*)
-- if c = 0
	\end{lcverbatim}
}

\subsection{\K{BR}}
For arithmetic expressions, you should write like \K{\$(l+1)}, instead of \K{l+1}.\\
Use \K{\^} for a sequence with given length. e.g. \K{instr}\K{\^}\K{n}. \\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/br-zero:
z; (LABEL_ n `{instr'*} val'* val^n (BR 0) instr*)  ~>  z; val^n instr'*

rule Step/br-succ:
z; (LABEL_ n `{instr'*} val* (BR $(l+1)) instr*)  ~>  z; val* (BR l)
	\end{lcverbatim}
}

\subsection{\K{BR\_IF}}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/br_if-true:
  z; (CONST I32 c) (BR_IF l)  ~>  z; (BR l)
  -- if c =/= 0

rule Step/br_if-false:
  z; (CONST I32 c) (BR_IF l)  ~>  z; eps
  -- if c = 0
	\end{lcverbatim}
}

\subsection{\K{CALL}}
To get a sequence of \K{funcaddr} from \K{state z}, write \K{\$funcaddr(z)}.\\
To get \K{n}th element of sequence \K{seq}, write \K{seq[n]}.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/call:
  z; (CALL x)  ~>  z; (CALL_ADDR $funcaddr(z)[x])
	\end{lcverbatim}
}

\subsection{\K{FRAME}}
To indicate a frame, refer to following syntax:
\begin{lcverbatim}
FRAME_ n `{frame} admininstr*
\end{lcverbatim}
$\\$
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/frame-vals:
  z; (FRAME_ n `{f} val^n)  ~>  z; val^n
	\end{lcverbatim}
}

\subsection{\K{RETURN}}
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/return-frame:
  z; (FRAME_ n `{f} val'* val^n RETURN instr*)  ~>  z; val^n

rule Step/return-label:
  z; (LABEL_ n `{instr'*} val* RETURN instr*)  ~>  z; val* RETURN
	\end{lcverbatim}
}

\subsection{\K{LOCAL.GET}}
To get a local value from \K{state z} and \K{idx x}, write \K{\$local(z, x)}.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/local.get:
  z; (LOCAL.GET x)  ~>  z; $local(z, x)
	\end{lcverbatim}
}

\subsection{\K{LOCAL.SET}}
To get a new state which is exactly same with \K{state z} except that its local value with \K{idx x} is \K{val v}, write \K{\$with\_local(z, x, v)}.\\\\
{\color{red}
	Answer:
	\begin{lcverbatim}
rule Step/local.set:
  z; val (LOCAL.SET x)  ~>  $with_local(z, x, val); eps
	\end{lcverbatim}
}


%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(address)} & {\mathit{addr}} &::=& {\mathit{nat}} \\
%	\mbox{(function address)} & {\mathit{funcaddr}} &::=& {\mathit{addr}} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(value)} & {\mathit{val}} &::=& {\mathit{valtype}}{.}\mathsf{const}~{{\mathit{val}}}_{{\mathit{valtype}}} \\
%	\mbox{(result)} & {\mathit{result}} &::=& {{\mathit{val}}^\ast} ~|~ \mathsf{trap} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(external value)} & {\mathit{externval}} &::=& \mathsf{func}~{\mathit{funcaddr}} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(function instance)} & {\mathit{funcinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{type}~{\mathit{functype}},\; \\
%		\mathsf{module}~{\mathit{moduleinst}},\; \\
%		\mathsf{code}~{\mathit{func}} \}\end{array} \\
%	\mbox{(export instance)} & {\mathit{exportinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{name}~{\mathit{name}},\; \\
%		\mathsf{value}~{\mathit{externval}} \}\end{array} \\
%	\mbox{(module instance)} & {\mathit{moduleinst}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{types}~{{\mathit{functype}}^\ast},\; \\
%		\mathsf{funcs}~{{\mathit{funcaddr}}^\ast},\; \\
%		\mathsf{exports}~{{\mathit{exportinst}}^\ast} \}\end{array} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(store)} & {\mathit{store}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{funcs}~{{\mathit{funcinst}}^\ast} \}\end{array} \\
%	\mbox{(frame)} & {\mathit{frame}} &::=& \{ \begin{array}[t]{@{}l@{}l@{}}
%		\mathsf{locals}~{{\mathit{val}}^\ast},\; \\
%		\mathsf{module}~{\mathit{moduleinst}} \}\end{array} \\
%	\mbox{(state)} & {\mathit{state}} &::=& {\mathit{store}} ; {\mathit{frame}} \\
%	\mbox{(configuration)} & {\mathit{config}} &::=& {\mathit{state}} ; {{\mathit{instr}}^\ast} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lrrl@{}l@{}}
%	\mbox{(administrative instruction)} & {\mathit{instr}} &::=& {\mathit{instr}} \\ &&|&
%	\mathsf{call}~{\mathit{funcaddr}} \\ &&|&
%	{{\mathsf{label}}_{n}}{\{{{\mathit{instr}}^\ast}\}}~{{\mathit{instr}}^\ast} \\ &&|&
%	{{\mathsf{frame}}_{n}}{\{{\mathit{frame}}\}}~{{\mathit{instr}}^\ast} \\ &&|&
%	\mathsf{trap} \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	(s ; f){.}\mathsf{module}{.}\mathsf{funcs} &=& f{.}\mathsf{module}{.}\mathsf{funcs} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	(s ; f){.}\mathsf{locals}{}[x] &=& f{.}\mathsf{locals}{}[x] \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	(s ; f){}[\mathsf{locals}{}[x] = v] &=& s ; f{}[\mathsf{locals}{}[x] = v] \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	(s ; f){.}\mathsf{funcs} &=& s{.}\mathsf{funcs} \\
%\end{array}
%$$
%
%${{\mathit{config}} \hookrightarrow {\mathit{config}}}$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}nop}]} \quad & z ; \mathsf{nop} &\hookrightarrow& z ; \epsilon \\
%	{[\textsc{\scriptsize E{-}drop}]} \quad & z ; {\mathit{val}}~\mathsf{drop} &\hookrightarrow& z ; \epsilon \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}select{-}true}]} \quad & z ; {\mathit{val}}_1~{\mathit{val}}_2~(\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~\mathsf{select} &\hookrightarrow& z ; {\mathit{val}}_1
%	&\qquad \mbox{if}~c \neq 0 \\
%	{[\textsc{\scriptsize E{-}select{-}false}]} \quad & z ; {\mathit{val}}_1~{\mathit{val}}_2~(\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~\mathsf{select} &\hookrightarrow& z ; {\mathit{val}}_2
%	&\qquad \mbox{if}~c = 0 \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}block}]} \quad & z ; (\mathsf{block}~{t^?}~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; ({{\mathsf{label}}_{n}}{\{\epsilon\}}~{{\mathit{instr}}^\ast})
%	&\qquad \mbox{if}~{t^?} = \epsilon \land n = 0 \lor {t^?} \neq \epsilon \land n = 1 \\
%	{[\textsc{\scriptsize E{-}loop}]} \quad & z ; (\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; ({{\mathsf{label}}_{0}}{\{\mathsf{loop}~{t^?}~{{\mathit{instr}}^\ast}\}}~{{\mathit{instr}}^\ast}) \\
%	{[\textsc{\scriptsize E{-}if{-}true}]} \quad & z ; (\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~(\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast}) &\hookrightarrow& z ; (\mathsf{block}~{t^?}~{{\mathit{instr}}_1^\ast})
%	&\qquad \mbox{if}~c \neq 0 \\
%	{[\textsc{\scriptsize E{-}if{-}false}]} \quad & z ; (\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~(\mathsf{if}~{t^?}~{{\mathit{instr}}_1^\ast}~\mathsf{else}~{{\mathit{instr}}_2^\ast}) &\hookrightarrow& z ; (\mathsf{block}~{t^?}~{{\mathit{instr}}_2^\ast})
%	&\qquad \mbox{if}~c = 0 \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}br{-}zero}]} \quad & z ; ({{\mathsf{label}}_{n}}{\{{{\mathit{instr}'}^\ast}\}}~{{\mathit{val}'}^\ast}~{{\mathit{val}}^{n}}~(\mathsf{br}~0)~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; {{\mathit{val}}^{n}}~{{\mathit{instr}'}^\ast} \\
%	{[\textsc{\scriptsize E{-}br{-}succ}]} \quad & z ; ({{\mathsf{label}}_{n}}{\{{{\mathit{instr}'}^\ast}\}}~{{\mathit{val}}^\ast}~(\mathsf{br}~l + 1)~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; {{\mathit{val}}^\ast}~(\mathsf{br}~l) \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}br\_if{-}true}]} \quad & z ; (\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~(\mathsf{br\_if}~l) &\hookrightarrow& z ; (\mathsf{br}~l)
%	&\qquad \mbox{if}~c \neq 0 \\
%	{[\textsc{\scriptsize E{-}br\_if{-}false}]} \quad & z ; (\mathsf{i{\scriptstyle32}}{.}\mathsf{const}~c)~(\mathsf{br\_if}~l) &\hookrightarrow& z ; \epsilon
%	&\qquad \mbox{if}~c = 0 \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}call}]} \quad & z ; (\mathsf{call}~x) &\hookrightarrow& z ; (\mathsf{call}~z{.}\mathsf{module}{.}\mathsf{funcs}{}[x]) \\
%	{[\textsc{\scriptsize E{-}frame{-}vals}]} \quad & z ; ({{\mathsf{frame}}_{n}}{\{f\}}~{{\mathit{val}}^{n}}) &\hookrightarrow& z ; {{\mathit{val}}^{n}} \\
%	{[\textsc{\scriptsize E{-}return{-}frame}]} \quad & z ; ({{\mathsf{frame}}_{n}}{\{f\}}~{{\mathit{val}'}^\ast}~{{\mathit{val}}^{n}}~\mathsf{return}~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; {{\mathit{val}}^{n}} \\
%	{[\textsc{\scriptsize E{-}return{-}label}]} \quad & z ; ({{\mathsf{label}}_{n}}{\{{{\mathit{instr}'}^\ast}\}}~{{\mathit{val}}^\ast}~\mathsf{return}~{{\mathit{instr}}^\ast}) &\hookrightarrow& z ; {{\mathit{val}}^\ast}~\mathsf{return} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{{\mathsf{add}}{{}_{t}}}{(c_1,\, c_2)} &=& {{\mathrm{iadd}}}_{{|t|}}(c_1, c_2) \\
%	{{\mathsf{sub}}{{}_{t}}}{(c_1,\, c_2)} &=& {{\mathrm{isub}}}_{{|t|}}(c_1, c_2) \\
%	{{\mathsf{mul}}{{}_{t}}}{(c_1,\, c_2)} &=& {{\mathrm{imul}}}_{{|t|}}(c_1, c_2) \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}binop{-}val}]} \quad & z ; (t{.}\mathsf{const}~c_1)~(t{.}\mathsf{const}~c_2)~(t . {\mathit{binop}}) &\hookrightarrow& z ; (t{.}\mathsf{const}~c)
%	&\qquad \mbox{if}~{{{\mathit{binop}}}{{}_{t}}}{(c_1,\, c_2)} = c \\
%	{[\textsc{\scriptsize E{-}binop{-}trap}]} \quad & z ; (t{.}\mathsf{const}~c_1)~(t{.}\mathsf{const}~c_2)~(t . {\mathit{binop}}) &\hookrightarrow& z ; \mathsf{trap}
%	&\qquad \mbox{if}~{{{\mathit{binop}}}{{}_{t}}}{(c_1,\, c_2)} = \epsilon \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}l@{}rcl@{}l@{}}
%	{[\textsc{\scriptsize E{-}local.get}]} \quad & z ; (\mathsf{local.get}~x) &\hookrightarrow& z ; z{.}\mathsf{locals}{}[x] \\
%	{[\textsc{\scriptsize E{-}local.set}]} \quad & z ; {\mathit{val}}~(\mathsf{local.set}~x) &\hookrightarrow& z{}[\mathsf{locals}{}[x] = {\mathit{val}}] ; \epsilon \\
%	{[\textsc{\scriptsize E{-}local.tee}]} \quad & z ; {\mathit{val}}~(\mathsf{local.tee}~x) &\hookrightarrow& z ; {\mathit{val}}~{\mathit{val}}~(\mathsf{local.set}~x) \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{funcs}}(\epsilon) &=& \epsilon \\
%	{\mathrm{funcs}}((\mathsf{func}~{\mathit{fa}})~{{\mathit{externval}'}^\ast}) &=& {\mathit{fa}}~{\mathrm{funcs}}({{\mathit{externval}'}^\ast}) \\
%	{\mathrm{funcs}}({\mathit{externval}}~{{\mathit{externval}'}^\ast}) &=& {\mathrm{funcs}}({{\mathit{externval}'}^\ast})
%	&\qquad \mbox{otherwise} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{allocfunc}}(s, {\mathit{mm}}, {\mathit{func}}) &=& (s{}[\mathsf{funcs} = ..{\mathit{fi}}],\, {|s{.}\mathsf{funcs}|})
%	&\qquad \mbox{if}~{\mathit{fi}} = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{type}~{\mathit{mm}}{.}\mathsf{types}{}[x],\; \mathsf{module}~{\mathit{mm}},\; \mathsf{code}~{\mathit{func}} \}\end{array} \\
%	&&&\qquad {\land}~{\mathit{func}} = \mathsf{func}~x~{{\mathit{local}}^\ast}~{\mathit{expr}} \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{allocfuncs}}(s, {\mathit{mm}}, \epsilon) &=& (s,\, \epsilon) \\
%	{\mathrm{allocfuncs}}(s, {\mathit{mm}}, {\mathit{func}}~{{\mathit{func}'}^\ast}) &=& (s_2,\, {\mathit{fa}}~{{\mathit{fa}'}^\ast})
%	&\qquad \mbox{if}~(s_1,\, {\mathit{fa}}) = {\mathrm{allocfunc}}(s, {\mathit{mm}}, {\mathit{func}}) \\
%	&&&\qquad {\land}~(s_2,\, {{\mathit{fa}'}^\ast}) = {\mathrm{allocfuncs}}(s_1, {\mathit{mm}}, {{\mathit{func}'}^\ast}) \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{instexport}}({{\mathit{fa}}^\ast}, \mathsf{export}~{\mathit{name}}~(\mathsf{func}~x)) &=& \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{name}~{\mathit{name}},\; \mathsf{value}~(\mathsf{func}~{{\mathit{fa}}^\ast}{}[x]) \}\end{array} \\
%\end{array}
%$$
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externval}}^\ast}) &=& (s_1,\, {\mathit{mm}})
%	&\qquad \mbox{if}~{\mathit{module}} = \begin{array}[t]{@{}l@{}} \mathsf{module} \\ {(\mathsf{type}~{\mathit{ft}})^\ast} \\ {{\mathit{func}}^{n_{\mathit{func}}}} \\ {{\mathit{start}}^?} \\ {{\mathit{export}}^\ast} \end{array} \\
%	&&&\qquad {\land}~{{\mathit{fa}}_{\mathit{ex}}^\ast} = {\mathrm{funcs}}({{\mathit{externval}}^\ast}) \\
%	&&&\qquad {\land}~{{\mathit{fa}}^\ast} = {{|s{.}\mathsf{funcs}|} + i_{\mathit{func}}^{i_{\mathit{func}}<n_{\mathit{func}}}} \\
%	&&&\qquad {\land}~{{\mathit{xi}}^\ast} = {{\mathrm{instexport}}({{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast}, {\mathit{export}})^\ast} \\
%	&&&\qquad {\land}~{\mathit{mm}} = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{types}~{{\mathit{ft}}^\ast},\; \\
%		\mathsf{funcs}~{{\mathit{fa}}_{\mathit{ex}}^\ast}~{{\mathit{fa}}^\ast},\; \\
%		\mathsf{exports}~{{\mathit{xi}}^\ast} \}\end{array} \\
%	&&&\qquad {\land}~(s_1,\, {{\mathit{fa}}^\ast}) = {\mathrm{allocfuncs}}(s, {\mathit{mm}}, {{\mathit{func}}^{n_{\mathit{func}}}}) \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{instantiate}}(s, {\mathit{module}}, {{\mathit{externval}}^\ast}) &=& s_1 ; f ; {(\mathsf{call}~{x'})^?}
%	&\qquad \mbox{if}~{\mathit{module}} = \mathsf{module}~{{\mathit{type}}^\ast}~{{\mathit{func}}^\ast}~{{\mathit{start}}^?}~{{\mathit{export}}^\ast} \\
%	&&&\qquad {\land}~{{\mathit{type}}^\ast} = {(\mathsf{type}~{\mathit{functype}})^\ast} \\
%	&&&\qquad {\land}~{{\mathit{start}}^?} = {(\mathsf{start}~{x'})^?} \\
%	&&&\qquad {\land}~n_{\mathsf{f}} = {|{{\mathit{func}}^\ast}|} \\
%	&&&\qquad {\land}~{\mathit{mm}}_{\mathit{init}} = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{types}~{{\mathit{functype}}^\ast},\; \\
%		\mathsf{funcs}~{\mathrm{funcs}}({{\mathit{externval}}^\ast})~{{|s{.}\mathsf{funcs}|} + i_{\mathsf{f}}^{i_{\mathsf{f}}<n_{\mathsf{f}}}} \}\end{array} \\
%	&&&\qquad {\land}~f_{\mathit{init}} = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{module}~{\mathit{mm}}_{\mathit{init}} \}\end{array} \\
%	&&&\qquad {\land}~z = s ; f_{\mathit{init}} \\
%	&&&\qquad {\land}~(s_1,\, {\mathit{mm}}) = {\mathrm{allocmodule}}(s, {\mathit{module}}, {{\mathit{externval}}^\ast}) \\
%	&&&\qquad {\land}~f = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{module}~{\mathit{mm}} \}\end{array} \\
%\end{array}
%$$
%
%\vspace{1ex}
%
%$$
%\begin{array}{@{}lcl@{}l@{}}
%	{\mathrm{invoke}}(s, {\mathit{fa}}, {{\mathit{val}}^{n}}) &=& s ; f ; {{\mathit{val}}^{n}}~(\mathsf{call}~{\mathit{fa}})
%	&\qquad \mbox{if}~f = \{ \begin{array}[t]{@{}l@{}}
%		\mathsf{module}~\{ \begin{array}[t]{@{}l@{}}
%			\}\end{array} \}\end{array} \\
%	&&&\qquad {\land}~(s ; f){.}\mathsf{funcs}{}[{\mathit{fa}}]{.}\mathsf{type} = {t_1^{n}} \rightarrow {t_2^\ast} \\
%\end{array}
%$$

\end{document}
