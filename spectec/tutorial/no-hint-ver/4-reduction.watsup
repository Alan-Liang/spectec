;;
;; Configurations
;;

relation Step: config ~> config
relation Step_pure: admininstr* ~> admininstr*
relation Step_read: config ~> admininstr*
relation Steps: config ~>* config

rule Step/pure:
  z; instr*  ~>  z; instr'*
  -- Step_pure: instr* ~> instr'*

rule Step/read:
  z; instr*  ~>  z; instr'*
  -- Step_read: z; instr* ~> instr'*

rule Steps/refl:
  z; admininstr* ~>* z; admininstr*

rule Steps/trans:
  z; admininstr*  ~>*  z''; admininstr''*
  -- Step: z; admininstr*  ~>  z'; admininstr'*
  -- Steps: z'; admininstr'  ~>*  z''; admininstr''*

;;
;; Instructions
;;

;; Polymorphic instructions

rule Step_pure/nop:
  NOP  ~>  eps

rule Step_pure/drop:
  val DROP  ~>  eps


rule Step_pure/select-true:
  val_1 val_2 (CONST I32 c) SELECT  ~>  val_1
  -- if c =/= 0

rule Step_pure/select-false:
  val_1 val_2 (CONST I32 c) SELECT  ~>  val_2
  -- if c = 0


;; Block instructions

rule Step_read/block:
  z; (BLOCK (eps -> t?) instr*)  ~>  (LABEL_ n `{eps} instr*)
  -- if t? = eps /\ n = 0 \/ t? =/= eps /\ n = 1  ;; TODO: allow |t?|

rule Step_read/loop:
  z; (LOOP ft instr*)  ~>  (LABEL_ 0 `{LOOP ft instr*} instr*)

rule Step_pure/if-true:
  (CONST I32 c) (IF ft instr_1* ELSE instr_2*)  ~>  (BLOCK ft instr_1*)
  -- if c =/= 0

rule Step_pure/if-false:
  (CONST I32 c) (IF ft instr_1* ELSE instr_2*)  ~>  (BLOCK ft instr_2*)
  -- if c = 0


;; Branch instructions

;; TODO: may want a label context instead of bubbling up
rule Step_pure/br-zero:
  (LABEL_ n `{instr'*} val'* val^n (BR 0) instr*)  ~>  val^n instr'*

rule Step_pure/br-succ:
  (LABEL_ n `{instr'*} val* (BR $(l+1)) instr*)  ~>  val* (BR l)


rule Step_pure/br_if-true:
  (CONST I32 c) (BR_IF l)  ~>  (BR l)
  -- if c =/= 0

rule Step_pure/br_if-false:
  (CONST I32 c) (BR_IF l)  ~>  eps
  -- if c = 0


;; Function instructions

rule Step_read/call:
  z; val^k (CALL x)  ~>  (FRAME_ n `{f} (LABEL_ n `{eps} instr*))
  -- if a = $funcaddr(z)[x]
  -- if $funcinst(z)[a] = {TYPE (t_1^k -> t_2^n), MODULE mm, CODE func}
  -- if func = FUNC x (LOCAL t)* instr*
  -- if f = {LOCALS val^k ($default_(t))*, MODULE mm}

rule Step_pure/frame-vals:
  (FRAME_ n `{f} val^n)  ~>  val^n

rule Step_pure/return-frame:
  (FRAME_ n `{f} val'* val^n RETURN instr*)  ~>  val^n

rule Step_pure/return-label:
  (LABEL_ n `{instr'*} val* RETURN instr*)  ~>  val* RETURN


;; Traps

rule Step_pure/trap-vals:
  val* TRAP instr*  ~>  TRAP
  -- if val* =/= eps \/ instr* =/= eps

rule Step_pure/trap-label:
  (LABEL_ n `{instr'*} TRAP)  ~>  TRAP

rule Step_pure/trap-frame:
  (FRAME_ n `{f} TRAP)  ~>  TRAP


;; Context

rule Step/ctxt-label:
  z; (LABEL_ n `{instr_0*} instr*)  ~>  z'; (LABEL_ n `{instr_0*} instr'*)
  -- Step: z; instr* ~> z'; instr'*

rule Step/ctxt-frame:
  s; f; (FRAME_ n `{f'} instr*)  ~>  s'; f; (FRAME_ n `{f'} instr'*)
  -- Step: s; f'; instr* ~> s'; f'; instr'*


;; Numeric instructions

def $binop(valtype, binop, num_(valtype), num_(valtype)) : num_(valtype)*

def $iadd(N, iN(N), iN(N)) : iN(N)
def $isub(N, iN(N), iN(N)) : iN(N)
def $imul(N, iN(N), iN(N)) : iN(N)
def $idiv(N, iN(N), iN(N)) : iN(N)*
def $iadd(N, c_1, c_2) = $((c_1 + c_2) \ 2^N)
def $isub(N, c_1, c_2) = $((c_1 - c_2 + 2^N) \ 2^N)
def $imul(N, c_1, c_2) = $((c_1 * c_2) \ 2^N)
def $idiv(N, c_1, 0) = eps
def $idiv(N, c_1, c_2) = $(c_1 / c_2)

def $binop(t, ADD, c_1, c_2) = $iadd($size(t), c_1, c_2)
def $binop(t, SUB, c_1, c_2) = $isub($size(t), c_1, c_2)
def $binop(t, MUL, c_1, c_2) = $imul($size(t), c_1, c_2)
def $binop(t, DIV, c_1, c_2) = $idiv($size(t), c_1, c_2)

rule Step_pure/binop-val:
  (CONST t c_1) (CONST t c_2) (BINOP t binop)  ~>  (CONST t c)
  -- if $binop(t, binop, c_1, c_2) = c  ;; TODO

rule Step_pure/binop-trap:
  (CONST t c_1) (CONST t c_2) (BINOP t binop)  ~>  TRAP
  -- if $binop(t, binop, c_1, c_2) = eps  ;; TODO


;; Local instructions

rule Step_read/local.get:
  z; (LOCAL.GET x)  ~>  $local(z, x)

rule Step/local.set:
  z; val (LOCAL.SET x)  ~>  $with_local(z, x, val); eps
