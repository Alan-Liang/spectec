;;
;; Contexts
;;

syntax context hint(desc "context") =
  { TYPES functype*, FUNCS functype*, 
    LOCALS valtype*, LABELS (valtype?)*, RETURN (valtype?)? }

var C : context



;;
;; Types
;;

relation Functype_ok: |- functype : OK      hint(show "K-func")

rule Functype_ok:
  |- t_1* -> t_2? : OK


;;
;; Subtyping
;;

;; External types

relation Functype_sub: |- functype <: functype       hint(show "S-func")


rule Functype_sub:
  |- ft <: ft


;;
;; Instructions
;;

relation Instr_ok: context |- instr : functype   hint(show "T")
relation Instrs_ok: context |- instr* : functype hint(show "T*")
relation Expr_ok: context |- expr : valtype?   hint(show "T-expr")


;; Expressions

rule Expr_ok:
  C |- instr* : t?
  -- Instrs_ok: C |- instr* : eps -> t?


;; Instruction sequences

rule Instrs_ok/empty:
  C |- eps : eps -> eps

rule Instrs_ok/seq:
  C |- instr_1 instr_2* : t_1* -> t_3*
  -- Instr_ok: C |- instr_1 : t_1* -> t_2*
  -- Instrs_ok: C |- instr_2 : t_2* -> t_3*

rule Instrs_ok/frame:
  C |- instr* : t* t_1* -> t* t_2*
  -- Instrs_ok: C |- instr* : t_1* -> t_2*


;; Parametric instructions

rule Instr_ok/nop:
  C |- NOP : eps -> eps

rule Instr_ok/drop:
  C |- DROP : t -> eps

rule Instr_ok/select:
  C |- SELECT : t t I32 -> t


;; Block instructions

rule Instr_ok/block:
  C |- BLOCK (eps -> t?) instr* : eps -> t?
  -- Instrs_ok: C, LABELS (t?) |- instr* : eps -> t?

rule Instr_ok/loop:
  C |- LOOP (eps -> t?) instr* : eps -> t?
  -- Instrs_ok: C, LABELS (eps) |- instr* : eps -> eps

rule Instr_ok/if:
  C |- IF (eps -> t?) instr_1* ELSE instr_2* : I32 -> t?
  -- Instrs_ok: C, LABELS (t?) |- instr_1* : eps -> t?
  -- Instrs_ok: C, LABELS (t?) |- instr_2* : eps -> t?


;; Branch instructions

rule Instr_ok/br:
  C |- BR l : t_1* t? -> t_2*
  -- if C.LABELS[l] = t?

rule Instr_ok/br_if:
  C |- BR_IF l : t? I32 -> t?
  -- if C.LABELS[l] = t?


;; Function instructions

rule Instr_ok/call:
  C |- CALL x : t_1* -> t_2?
  -- if C.FUNCS[x] = t_1* -> t_2?

rule Instr_ok/return:
  C |- RETURN : t_1* t? -> t_2*
  -- if C.RETURN = t?


;; Numeric instructions

rule Instr_ok/const:
  C |- CONST t c_t : eps -> t

rule Instr_ok/binop:
  C |- BINOP t binop_t : t t -> t


;; Local instructions

rule Instr_ok/local.get:
  C |- LOCAL.GET x : eps -> t
  -- if C.LOCALS[x] = t

rule Instr_ok/local.set:
  C |- LOCAL.SET x : t -> eps
  -- if C.LOCALS[x] = t


;;
;; Constant Expressions
;;

relation Instr_const: context |- instr CONST              hint(show "C-instr")
relation Expr_const: context |- expr CONST                hint(show "C-expr")
relation Expr_ok_const: context |- expr : valtype? CONST  hint(show "TC-expr")

rule Instr_const/const:
  C |- (CONST t c) CONST


rule Expr_const: C |- instr* CONST
  -- (Instr_const: C |- instr CONST)*


rule Expr_ok_const:
  C |- expr : t? CONST
  -- Expr_ok: C |- expr : t?
  -- Expr_const: C |- expr CONST


;;
;; Modules
;;

relation Type_ok: |- type : functype                 hint(show "T-type")
relation Func_ok: context |- func : functype         hint(show "T-func")


;; Module definitions

rule Type_ok:
  |- TYPE ft : ft
  -- Functype_ok: |- ft : OK

rule Func_ok:
  C |- FUNC x (LOCAL t)* expr : t_1* -> t_2?
  -- if C.TYPES[x] = t_1* -> t_2?
  -- Expr_ok: C, LOCALS t_1* t*, LABELS (t_2?), RETURN (t_2?) |- expr : t_2?


;; Module exports

relation Export_ok: context |- export : externtype        hint(show "T-export")
relation Externidx_ok: context |- externidx : externtype  hint(show "T-externidx")

rule Export_ok:
  C |- EXPORT name externidx : xt
  -- Externidx_ok: C |- externidx : xt


rule Externidx_ok/func:
  C |- FUNC x : FUNC ft
  -- if C.FUNCS[x] = ft


;; Modules proper

relation Module_ok: |- module : OK      hint(show "T-module")

rule Module_ok:
  |- MODULE type* func* export* : OK
  -- (Type_ok: |- type : ft')*
  -- (Func_ok: C |- func : ft)*
  -- (Export_ok: C |- export : xt)*
  -- if C = {TYPES ft'*, FUNCS ift* ft*}
