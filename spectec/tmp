
;; spec/1-syntax.watsup:3.1-3.15
syntax n = nat

;; spec/1-syntax.watsup:9.1-9.37
syntax name = text

;; spec/1-syntax.watsup:14.1-14.36
syntax byte = nat

;; spec/1-syntax.watsup:15.1-15.45
syntax u32 = nat

;; spec/1-syntax.watsup:22.1-22.36
syntax idx = nat

;; spec/1-syntax.watsup:23.1-23.49
syntax funcidx = idx

;; spec/1-syntax.watsup:24.1-24.49
syntax globalidx = idx

;; spec/1-syntax.watsup:25.1-25.47
syntax tableidx = idx

;; spec/1-syntax.watsup:26.1-26.46
syntax memidx = idx

;; spec/1-syntax.watsup:27.1-27.45
syntax elemidx = idx

;; spec/1-syntax.watsup:28.1-28.45
syntax dataidx = idx

;; spec/1-syntax.watsup:29.1-29.47
syntax labelidx = idx

;; spec/1-syntax.watsup:30.1-30.47
syntax localidx = idx

;; spec/1-syntax.watsup:39.1-40.22
syntax numtype = 
  | I32
  | I64
  | F32
  | F64

;; spec/1-syntax.watsup:41.1-42.5
syntax vectype = 
  | V128

;; spec/1-syntax.watsup:43.1-44.20
syntax reftype = 
  | FUNCREF
  | EXTERNREF

;; spec/1-syntax.watsup:45.1-46.34
syntax valtype = 
  | I32
  | I64
  | F32
  | F64
  | V128
  | FUNCREF
  | EXTERNREF
  | BOT

;; spec/1-syntax.watsup:48.1-48.39
syntax in = 
  | I32
  | I64

;; spec/1-syntax.watsup:49.1-49.39
syntax fn = 
  | F32
  | F64

;; spec/1-syntax.watsup:56.1-57.11
syntax resulttype = valtype*

;; spec/1-syntax.watsup:59.1-60.16
syntax limits = `[%..%]`(u32, u32)

;; spec/1-syntax.watsup:61.1-62.15
syntax globaltype = `MUT%?%`(()?, valtype)

;; spec/1-syntax.watsup:63.1-64.27
syntax functype = `%->%`(resulttype, resulttype)

;; spec/1-syntax.watsup:65.1-66.17
syntax tabletype = `%%`(limits, reftype)

;; spec/1-syntax.watsup:67.1-68.12
syntax memtype = `%I8`(limits)

;; spec/1-syntax.watsup:69.1-70.10
syntax elemtype = reftype

;; spec/1-syntax.watsup:71.1-72.5
syntax datatype = OK

;; spec/1-syntax.watsup:73.1-74.69
syntax externtype = 
  | GLOBAL(globaltype)
  | FUNC(functype)
  | TABLE(tabletype)
  | MEMORY(memtype)

;; spec/1-syntax.watsup:86.1-86.44
syntax sx = 
  | U
  | S

;; spec/1-syntax.watsup:88.1-88.39
syntax unop_IXX = 
  | CLZ
  | CTZ
  | POPCNT

;; spec/1-syntax.watsup:89.1-89.70
syntax unop_FXX = 
  | ABS
  | NEG
  | SQRT
  | CEIL
  | FLOOR
  | TRUNC
  | NEAREST

;; spec/1-syntax.watsup:91.1-93.62
syntax binop_IXX = 
  | ADD
  | SUB
  | MUL
  | DIV(sx)
  | REM(sx)
  | AND
  | OR
  | XOR
  | SHL
  | SHR(sx)
  | ROTL
  | ROTR

;; spec/1-syntax.watsup:94.1-94.66
syntax binop_FXX = 
  | ADD
  | SUB
  | MUL
  | DIV
  | MIN
  | MAX
  | COPYSIGN

;; spec/1-syntax.watsup:96.1-96.26
syntax testop_IXX = 
  | EQZ

;; spec/1-syntax.watsup:97.1-97.22
syntax testop_FXX = 
  | 

;; spec/1-syntax.watsup:99.1-100.108
syntax relop_IXX = 
  | EQ
  | NE
  | LT(sx)
  | GT(sx)
  | LE(sx)
  | GE(sx)

;; spec/1-syntax.watsup:101.1-101.49
syntax relop_FXX = 
  | EQ
  | NE
  | LT
  | GT
  | LE
  | GE

;; spec/1-syntax.watsup:103.1-103.50
syntax unop_numtype = 
  | _I(unop_IXX)
  | _F(unop_FXX)

;; spec/1-syntax.watsup:104.1-104.53
syntax binop_numtype = 
  | _I(binop_IXX)
  | _F(binop_FXX)

;; spec/1-syntax.watsup:105.1-105.56
syntax testop_numtype = 
  | _I(testop_IXX)
  | _F(testop_FXX)

;; spec/1-syntax.watsup:106.1-106.53
syntax relop_numtype = 
  | _I(relop_IXX)
  | _F(relop_FXX)

;; spec/1-syntax.watsup:107.1-107.39
syntax cvtop = 
  | CONVERT
  | REINTERPRET

;; spec/1-syntax.watsup:117.1-117.23
syntax c_numtype = nat

;; spec/1-syntax.watsup:118.1-118.23
syntax c_vectype = nat

;; spec/1-syntax.watsup:121.1-121.52
syntax blocktype = functype

;; spec/1-syntax.watsup:156.1-177.55
rec {

;; spec/1-syntax.watsup:156.1-177.55
syntax instr = 
  | UNREACHABLE
  | NOP
  | DROP
  | SELECT(valtype?)
  | BLOCK(blocktype, instr*)
  | LOOP(blocktype, instr*)
  | IF(blocktype, instr*, instr*)
  | BR(labelidx)
  | BR_IF(labelidx)
  | BR_TABLE(labelidx*, labelidx)
  | CALL(funcidx)
  | CALL_INDIRECT(tableidx, functype)
  | RETURN
  | CONST(numtype, c_numtype)
  | UNOP(numtype, unop_numtype)
  | BINOP(numtype, binop_numtype)
  | TESTOP(numtype, testop_numtype)
  | RELOP(numtype, relop_numtype)
  | EXTEND(numtype, n)
  | CVTOP(numtype, cvtop, numtype, sx?)
  | REF.NULL(reftype)
  | REF.FUNC(funcidx)
  | REF.IS_NULL
  | LOCAL.GET(localidx)
  | LOCAL.SET(localidx)
  | LOCAL.TEE(localidx)
  | GLOBAL.GET(globalidx)
  | GLOBAL.SET(globalidx)
  | TABLE.GET(tableidx)
  | TABLE.SET(tableidx)
  | TABLE.SIZE(tableidx)
  | TABLE.GROW(tableidx)
  | TABLE.FILL(tableidx)
  | TABLE.COPY(tableidx, tableidx)
  | TABLE.INIT(tableidx, elemidx)
  | ELEM.DROP(elemidx)
  | MEMORY.SIZE
  | MEMORY.GROW
  | MEMORY.FILL
  | MEMORY.COPY
  | MEMORY.INIT(dataidx)
  | DATA.DROP(dataidx)
  | LOAD(numtype, (n, sx)?, nat, nat)
  | STORE(numtype, n?, nat, nat)
}

;; spec/1-syntax.watsup:179.1-180.9
syntax expr = instr*

;; spec/1-syntax.watsup:185.1-185.50
syntax elemmode = 
  | TABLE(tableidx, expr)
  | DECLARE

;; spec/1-syntax.watsup:186.1-186.39
syntax datamode = 
  | MEMORY(memidx, expr)

;; spec/1-syntax.watsup:188.1-189.30
syntax func = `FUNC%%*%`(functype, valtype*, expr)

;; spec/1-syntax.watsup:190.1-191.25
syntax global = GLOBAL(globaltype, expr)

;; spec/1-syntax.watsup:192.1-193.18
syntax table = TABLE(tabletype)

;; spec/1-syntax.watsup:194.1-195.17
syntax mem = MEMORY(memtype)

;; spec/1-syntax.watsup:196.1-197.31
syntax elem = `ELEM%%*%?`(reftype, expr*, elemmode?)

;; spec/1-syntax.watsup:198.1-199.26
syntax data = `DATA(*)%*%?`(byte**, datamode?)

;; spec/1-syntax.watsup:200.1-201.16
syntax start = START(funcidx)

;; spec/1-syntax.watsup:203.1-204.65
syntax externuse = 
  | FUNC(funcidx)
  | GLOBAL(globalidx)
  | TABLE(tableidx)
  | MEMORY(memidx)

;; spec/1-syntax.watsup:205.1-206.24
syntax export = EXPORT(name, externuse)

;; spec/1-syntax.watsup:207.1-208.30
syntax import = IMPORT(name, name, externtype)

;; spec/1-syntax.watsup:210.1-211.70
syntax module = `MODULE%*%*%*%*%*%*%*%*%*`(import*, func*, global*, table*, mem*, elem*, data*, start*, export*)

;; spec/2-aux.watsup:5.1-5.55
def size : valtype -> nat
  ;; spec/2-aux.watsup:6.1-6.20
  def size(I32_valtype) = 32
  ;; spec/2-aux.watsup:7.1-7.20
  def size(I64_valtype) = 64
  ;; spec/2-aux.watsup:8.1-8.20
  def size(F32_valtype) = 32
  ;; spec/2-aux.watsup:9.1-9.20
  def size(F64_valtype) = 64
  ;; spec/2-aux.watsup:10.1-10.22
  def size(V128_valtype) = 128

;; spec/2-aux.watsup:15.1-15.40
def test_sub_ATOM_22 : n -> nat
  ;; spec/2-aux.watsup:16.1-16.38
  def {n_3_ATOM_y : n} test_sub_ATOM_22(n_3_ATOM_y) = 0

;; spec/2-aux.watsup:18.1-18.26
def curried_ : (n, n) -> nat
  ;; spec/2-aux.watsup:19.1-19.39
  def {n_1 : n, n_2 : n} curried_(n_1, n_2) = (n_1 + n_2)

;; spec/2-aux.watsup:21.1-30.39
syntax testfuse = 
  | AB_(nat, nat, nat)
  | CD(nat, nat, nat)
  | EF(nat, nat, nat)
  | GH(nat, nat, nat)
  | IJ(nat, nat, nat)
  | KL(nat, nat, nat)
  | MN(nat, nat, nat)
  | OP(nat, nat, nat)
  | QR(nat, nat, nat)

;; spec/4-runtime.watsup:3.1-3.39
syntax addr = nat

;; spec/4-runtime.watsup:4.1-4.53
syntax funcaddr = addr

;; spec/4-runtime.watsup:5.1-5.53
syntax globaladdr = addr

;; spec/4-runtime.watsup:6.1-6.51
syntax tableaddr = addr

;; spec/4-runtime.watsup:7.1-7.50
syntax memaddr = addr

;; spec/4-runtime.watsup:8.1-8.49
syntax elemaddr = addr

;; spec/4-runtime.watsup:9.1-9.49
syntax dataaddr = addr

;; spec/4-runtime.watsup:10.1-10.51
syntax labeladdr = addr

;; spec/4-runtime.watsup:11.1-11.49
syntax hostaddr = addr

;; spec/4-runtime.watsup:24.1-25.24
syntax num = 
  | CONST(numtype, c_numtype)

;; spec/4-runtime.watsup:26.1-27.67
syntax ref = 
  | REF.NULL(reftype)
  | REF.FUNC_ADDR(funcaddr)
  | REF.HOST_ADDR(hostaddr)

;; spec/4-runtime.watsup:28.1-29.10
syntax val = 
  | CONST(numtype, c_numtype)
  | REF.NULL(reftype)
  | REF.FUNC_ADDR(funcaddr)
  | REF.HOST_ADDR(hostaddr)

;; spec/4-runtime.watsup:31.1-32.18
syntax result = 
  | _VALS(val*)
  | TRAP

;; spec/4-runtime.watsup:38.1-39.66
syntax externval = 
  | FUNC(funcaddr)
  | GLOBAL(globaladdr)
  | TABLE(tableaddr)
  | MEM(memaddr)

;; spec/4-runtime.watsup:44.1-44.44
def default_ : valtype -> val
  ;; spec/4-runtime.watsup:45.1-45.35
  def default_(I32_valtype) = CONST_val(I32_numtype, 0)
  ;; spec/4-runtime.watsup:46.1-46.35
  def default_(I64_valtype) = CONST_val(I64_numtype, 0)
  ;; spec/4-runtime.watsup:47.1-47.35
  def default_(F32_valtype) = CONST_val(F32_numtype, 0)
  ;; spec/4-runtime.watsup:48.1-48.35
  def default_(F64_valtype) = CONST_val(F64_numtype, 0)
  ;; spec/4-runtime.watsup:49.1-49.34
  def {rt : reftype} default_(rt <: valtype) = REF.NULL_val(rt)

;; spec/4-runtime.watsup:60.1-60.71
syntax exportinst = EXPORT(name, externval)

;; spec/4-runtime.watsup:70.1-77.25
syntax moduleinst = {FUNC funcaddr*, GLOBAL globaladdr*, TABLE tableaddr*, MEM memaddr*, ELEM elemaddr*, DATA dataaddr*, EXPORT exportinst*}

;; spec/4-runtime.watsup:54.1-54.66
syntax funcinst = `%;%`(moduleinst, func)

;; spec/4-runtime.watsup:55.1-55.53
syntax globalinst = val

;; spec/4-runtime.watsup:56.1-56.52
syntax tableinst = ref*

;; spec/4-runtime.watsup:57.1-57.52
syntax meminst = byte*

;; spec/4-runtime.watsup:58.1-58.53
syntax eleminst = ref*

;; spec/4-runtime.watsup:59.1-59.51
syntax datainst = byte*

;; spec/4-runtime.watsup:62.1-68.21
syntax store = {FUNC funcinst*, GLOBAL globalinst*, TABLE tableinst*, MEM meminst*, ELEM eleminst*, DATA datainst*}

;; spec/4-runtime.watsup:79.1-81.24
syntax frame = {LOCAL val*, MODULE moduleinst}

;; spec/4-runtime.watsup:82.1-82.47
syntax state = `%;%`(store, frame)

;; spec/4-runtime.watsup:139.1-146.5
rec {

;; spec/4-runtime.watsup:139.1-146.5
syntax admininstr = 
  | UNREACHABLE
  | NOP
  | DROP
  | SELECT(valtype?)
  | BLOCK(blocktype, instr*)
  | LOOP(blocktype, instr*)
  | IF(blocktype, instr*, instr*)
  | BR(labelidx)
  | BR_IF(labelidx)
  | BR_TABLE(labelidx*, labelidx)
  | CALL(funcidx)
  | CALL_INDIRECT(tableidx, functype)
  | RETURN
  | CONST(numtype, c_numtype)
  | UNOP(numtype, unop_numtype)
  | BINOP(numtype, binop_numtype)
  | TESTOP(numtype, testop_numtype)
  | RELOP(numtype, relop_numtype)
  | EXTEND(numtype, n)
  | CVTOP(numtype, cvtop, numtype, sx?)
  | REF.NULL(reftype)
  | REF.FUNC(funcidx)
  | REF.IS_NULL
  | LOCAL.GET(localidx)
  | LOCAL.SET(localidx)
  | LOCAL.TEE(localidx)
  | GLOBAL.GET(globalidx)
  | GLOBAL.SET(globalidx)
  | TABLE.GET(tableidx)
  | TABLE.SET(tableidx)
  | TABLE.SIZE(tableidx)
  | TABLE.GROW(tableidx)
  | TABLE.FILL(tableidx)
  | TABLE.COPY(tableidx, tableidx)
  | TABLE.INIT(tableidx, elemidx)
  | ELEM.DROP(elemidx)
  | MEMORY.SIZE
  | MEMORY.GROW
  | MEMORY.FILL
  | MEMORY.COPY
  | MEMORY.INIT(dataidx)
  | DATA.DROP(dataidx)
  | LOAD(numtype, (n, sx)?, nat, nat)
  | STORE(numtype, n?, nat, nat)
  | REF.FUNC_ADDR(funcaddr)
  | REF.HOST_ADDR(hostaddr)
  | CALL_ADDR(funcaddr)
  | LABEL_(n, instr*, admininstr*)
  | FRAME_(n, frame, admininstr*)
  | TRAP
}

;; spec/4-runtime.watsup:83.1-83.62
syntax config = `%;%*`(state, admininstr*)

;; spec/4-runtime.watsup:101.1-101.59
def funcaddr : state -> funcaddr*
  ;; spec/4-runtime.watsup:102.1-102.38
  def {f : frame, s : store} funcaddr(`%;%`(s, f)) = f.MODULE_frame.FUNC_moduleinst

;; spec/4-runtime.watsup:104.1-104.52
def funcinst : state -> funcinst*
  ;; spec/4-runtime.watsup:105.1-105.31
  def {f : frame, s : store} funcinst(`%;%`(s, f)) = s.FUNC_store

;; spec/4-runtime.watsup:107.1-107.67
def func : (state, funcidx) -> funcinst
  ;; spec/4-runtime.watsup:115.1-115.48
  def {f : frame, s : store, x : idx} func(`%;%`(s, f), x) = s.FUNC_store[f.MODULE_frame.FUNC_moduleinst[x]]

;; spec/4-runtime.watsup:108.1-108.69
def global : (state, globalidx) -> globalinst
  ;; spec/4-runtime.watsup:116.1-116.54
  def {f : frame, s : store, x : idx} global(`%;%`(s, f), x) = s.GLOBAL_store[f.MODULE_frame.GLOBAL_moduleinst[x]]

;; spec/4-runtime.watsup:109.1-109.68
def table : (state, tableidx) -> tableinst
  ;; spec/4-runtime.watsup:117.1-117.51
  def {f : frame, s : store, x : idx} table(`%;%`(s, f), x) = s.TABLE_store[f.MODULE_frame.TABLE_moduleinst[x]]

;; spec/4-runtime.watsup:110.1-110.66
def mem : (state, memidx) -> meminst
  ;; spec/4-runtime.watsup:118.1-118.45
  def {f : frame, s : store, x : idx} mem(`%;%`(s, f), x) = s.MEM_store[f.MODULE_frame.MEM_moduleinst[x]]

;; spec/4-runtime.watsup:111.1-111.67
def elem : (state, tableidx) -> eleminst
  ;; spec/4-runtime.watsup:119.1-119.48
  def {f : frame, s : store, x : idx} elem(`%;%`(s, f), x) = s.ELEM_store[f.MODULE_frame.ELEM_moduleinst[x]]

;; spec/4-runtime.watsup:112.1-112.67
def data : (state, dataidx) -> datainst
  ;; spec/4-runtime.watsup:120.1-120.48
  def {f : frame, s : store, x : idx} data(`%;%`(s, f), x) = s.DATA_store[f.MODULE_frame.DATA_moduleinst[x]]

;; spec/4-runtime.watsup:113.1-113.68
def local : (state, localidx) -> val
  ;; spec/4-runtime.watsup:121.1-121.35
  def {f : frame, s : store, x : idx} local(`%;%`(s, f), x) = f.LOCAL_frame[x]

;; spec/4-runtime.watsup:124.1-124.78
def with_local : (state, localidx, val) -> state
  ;; spec/4-runtime.watsup:130.1-130.52
  def {f : frame, s : store, v : val, x : idx} with_local(`%;%`(s, f), x, v) = `%;%`(s, f[LOCAL[x] = v])

;; spec/4-runtime.watsup:125.1-125.79
def with_global : (state, globalidx, val) -> state
  ;; spec/4-runtime.watsup:131.1-131.71
  def {f : frame, s : store, v : val, x : idx} with_global(`%;%`(s, f), x, v) = `%;%`(s[GLOBAL[f.MODULE_frame.GLOBAL_moduleinst[x]] = v], f)

;; spec/4-runtime.watsup:126.1-126.81
def with_table : (state, tableidx, n, ref) -> state
  ;; spec/4-runtime.watsup:132.1-132.74
  def {f : frame, i : nat, r : ref, s : store, x : idx} with_table(`%;%`(s, f), x, i, r) = `%;%`(s[TABLE[f.MODULE_frame.TABLE_moduleinst[x]][i] = r], f)

;; spec/4-runtime.watsup:127.1-127.80
def with_tableext : (state, tableidx, ref*) -> state
  ;; spec/4-runtime.watsup:133.1-133.75
  def {f : frame, r* : ref*, s : store, x : idx} with_tableext(`%;%`(s, f), x, r*{r}) = `%;%`(s[TABLE[f.MODULE_frame.TABLE_moduleinst[x]] =.. r*{r}], f)

;; spec/4-runtime.watsup:128.1-128.77
def with_elem : (state, elemidx, ref*) -> state
  ;; spec/4-runtime.watsup:134.1-134.69
  def {f : frame, r* : ref*, s : store, x : idx} with_elem(`%;%`(s, f), x, r*{r}) = `%;%`(s[TABLE[f.MODULE_frame.TABLE_moduleinst[x]] = r*{r}], f)

;; spec/4-runtime.watsup:148.1-151.21
rec {

;; spec/4-runtime.watsup:148.1-151.21
syntax E = 
  | _HOLE
  | _SEQ(val*, E, instr*)
  | LABEL_(n, instr*, E)
}

;; spec/5-numerics.watsup:3.1-3.76
def unop : (unop_numtype, numtype, c_numtype) -> c_numtype*

;; spec/5-numerics.watsup:4.1-4.79
def binop : (binop_numtype, numtype, c_numtype, c_numtype) -> c_numtype*

;; spec/5-numerics.watsup:5.1-5.76
def testop : (testop_numtype, numtype, c_numtype) -> c_numtype

;; spec/5-numerics.watsup:6.1-6.79
def relop : (relop_numtype, numtype, c_numtype, c_numtype) -> c_numtype

;; spec/5-numerics.watsup:8.1-8.84
def ext : (nat, nat, sx, c_numtype) -> c_numtype

;; spec/5-numerics.watsup:9.1-9.84
def cvtop : (numtype, cvtop, numtype, sx?, c_numtype) -> c_numtype*

;; spec/6-reduction.watsup:4.1-4.63
relation Step_pure: `%*~>%*`(admininstr*, admininstr*)
  ;; spec/6-reduction.watsup:16.1-17.24
  rule unreachable:
    `%*~>%*`([UNREACHABLE_admininstr], [TRAP_admininstr])

  ;; spec/6-reduction.watsup:19.1-20.19
  rule nop:
    `%*~>%*`([NOP_admininstr], [])

  ;; spec/6-reduction.watsup:22.1-23.24
  rule drop {val : val}:
    `%*~>%*`([(val <: admininstr) DROP_admininstr], [])

  ;; spec/6-reduction.watsup:26.1-28.16
  rule select-true {c : c_numtype, t? : valtype?, val_1 : val, val_2 : val}:
    `%*~>%*`([(val_1 <: admininstr) (val_2 <: admininstr) CONST_admininstr(I32_numtype, c) SELECT_admininstr(t?{t})], [(val_1 <: admininstr)])
    -- if (c =/= 0)

  ;; spec/6-reduction.watsup:30.1-32.14
  rule select-false {c : c_numtype, t? : valtype?, val_1 : val, val_2 : val}:
    `%*~>%*`([(val_1 <: admininstr) (val_2 <: admininstr) CONST_admininstr(I32_numtype, c) SELECT_admininstr(t?{t})], [(val_2 <: admininstr)])
    -- if (c = 0)

  ;; spec/6-reduction.watsup:35.1-37.28
  rule block {bt : blocktype, instr* : instr*, k : nat, n : n, t_1^k : valtype^k, t_2^n : valtype^n, val^k : val^k}:
    `%*~>%*`((val <: admininstr)^k{val} :: [BLOCK_admininstr(bt, instr*{instr})], [LABEL__admininstr(n, [], (val <: admininstr)^k{val} :: (instr <: admininstr)*{instr})])
    -- if (bt = `%->%`(t_1^k{t_1}, t_2^n{t_2}))

  ;; spec/6-reduction.watsup:39.1-41.28
  rule loop {bt : blocktype, instr* : instr*, k : nat, n : n, t_1^k : valtype^k, t_2^n : valtype^n, val^k : val^k}:
    `%*~>%*`((val <: admininstr)^k{val} :: [LOOP_admininstr(bt, instr*{instr})], [LABEL__admininstr(n, [LOOP_instr(bt, instr*{instr})], (val <: admininstr)^k{val} :: (instr <: admininstr)*{instr})])
    -- if (bt = `%->%`(t_1^k{t_1}, t_2^n{t_2}))

  ;; spec/6-reduction.watsup:43.1-45.16
  rule if-true {bt : blocktype, c : c_numtype, instr_1* : instr*, instr_2* : instr*}:
    `%*~>%*`([CONST_admininstr(I32_numtype, c) IF_admininstr(bt, instr_1*{instr_1}, instr_2*{instr_2})], [BLOCK_admininstr(bt, instr_1*{instr_1})])
    -- if (c =/= 0)

  ;; spec/6-reduction.watsup:47.1-49.14
  rule if-false {bt : blocktype, c : c_numtype, instr_1* : instr*, instr_2* : instr*}:
    `%*~>%*`([CONST_admininstr(I32_numtype, c) IF_admininstr(bt, instr_1*{instr_1}, instr_2*{instr_2})], [BLOCK_admininstr(bt, instr_2*{instr_2})])
    -- if (c = 0)

  ;; spec/6-reduction.watsup:52.1-53.38
  rule label-vals {instr* : instr*, n : n, val* : val*}:
    `%*~>%*`([LABEL__admininstr(n, instr*{instr}, (val <: admininstr)*{val})], (val <: admininstr)*{val})

  ;; spec/6-reduction.watsup:57.1-58.69
  rule br-zero {instr* : instr*, instr'* : instr*, n : n, val^n : val^n, val'* : val*}:
    `%*~>%*`([LABEL__admininstr(n, instr'*{instr'}, (val' <: admininstr)*{val'} :: (val <: admininstr)^n{val} :: [BR_admininstr(0)] :: (instr <: admininstr)*{instr})], (val <: admininstr)^n{val} :: (instr' <: admininstr)*{instr'})

  ;; spec/6-reduction.watsup:60.1-61.65
  rule br-succ {instr* : instr*, instr'* : instr*, l : labelidx, n : n, val* : val*}:
    `%*~>%*`([LABEL__admininstr(n, instr'*{instr'}, (val <: admininstr)*{val} :: [BR_admininstr(l + 1)] :: (instr <: admininstr)*{instr})], (val <: admininstr)*{val} :: [BR_admininstr(l)])

  ;; spec/6-reduction.watsup:64.1-66.16
  rule br_if-true {c : c_numtype, l : labelidx}:
    `%*~>%*`([CONST_admininstr(I32_numtype, c) BR_IF_admininstr(l)], [BR_admininstr(l)])
    -- if (c =/= 0)

  ;; spec/6-reduction.watsup:68.1-70.14
  rule br_if-false {c : c_numtype, l : labelidx}:
    `%*~>%*`([CONST_admininstr(I32_numtype, c) BR_IF_admininstr(l)], [])
    -- if (c = 0)

  ;; spec/6-reduction.watsup:73.1-75.17
  rule br_table-lt {i : nat, l* : labelidx*, l' : labelidx}:
    `%*~>%*`([CONST_admininstr(I32_numtype, i) BR_TABLE_admininstr(l*{l}, l')], [BR_admininstr(l*{l}[i])])
    -- if (i < |l*{l}|)

  ;; spec/6-reduction.watsup:77.1-79.18
  rule br_table-ge {i : nat, l* : labelidx*, l' : labelidx}:
    `%*~>%*`([CONST_admininstr(I32_numtype, i) BR_TABLE_admininstr(l*{l}, l')], [BR_admininstr(l')])
    -- if (i >= |l*{l}|)

  ;; spec/6-reduction.watsup:100.1-101.35
  rule frame-vals {f : frame, n : n, val^n : val^n}:
    `%*~>%*`([FRAME__admininstr(n, f, (val <: admininstr)^n{val})], (val <: admininstr)^n{val})

  ;; spec/6-reduction.watsup:103.1-104.55
  rule return-frame {f : frame, instr* : instr*, n : n, val^n : val^n, val'* : val*}:
    `%*~>%*`([FRAME__admininstr(n, f, (val' <: admininstr)*{val'} :: (val <: admininstr)^n{val} :: [RETURN_admininstr] :: (instr <: admininstr)*{instr})], (val <: admininstr)^n{val})

  ;; spec/6-reduction.watsup:106.1-107.60
  rule return-label {instr* : instr*, instr'* : instr*, k : nat, val* : val*}:
    `%*~>%*`([LABEL__admininstr(k, instr'*{instr'}, (val <: admininstr)*{val} :: [RETURN_admininstr] :: (instr <: admininstr)*{instr})], (val <: admininstr)*{val} :: [RETURN_admininstr])

  ;; spec/6-reduction.watsup:110.1-112.33
  rule unop-val {c : c_numtype, c_1 : c_numtype, nt : numtype, unop : unop_numtype}:
    `%*~>%*`([CONST_admininstr(nt, c_1) UNOP_admininstr(nt, unop)], [CONST_admininstr(nt, c)])
    -- if ($unop(unop, nt, c_1) = [c])

  ;; spec/6-reduction.watsup:114.1-116.39
  rule unop-trap {c_1 : c_numtype, nt : numtype, unop : unop_numtype}:
    `%*~>%*`([CONST_admininstr(nt, c_1) UNOP_admininstr(nt, unop)], [TRAP_admininstr])
    -- if ($unop(unop, nt, c_1) = [])

  ;; spec/6-reduction.watsup:119.1-121.40
  rule binop-val {binop : binop_numtype, c : c_numtype, c_1 : c_numtype, c_2 : c_numtype, nt : numtype}:
    `%*~>%*`([CONST_admininstr(nt, c_1) CONST_admininstr(nt, c_2) BINOP_admininstr(nt, binop)], [CONST_admininstr(nt, c)])
    -- if ($binop(binop, nt, c_1, c_2) = [c])

  ;; spec/6-reduction.watsup:123.1-125.46
  rule binop-trap {binop : binop_numtype, c_1 : c_numtype, c_2 : c_numtype, nt : numtype}:
    `%*~>%*`([CONST_admininstr(nt, c_1) CONST_admininstr(nt, c_2) BINOP_admininstr(nt, binop)], [TRAP_admininstr])
    -- if ($binop(binop, nt, c_1, c_2) = [])

  ;; spec/6-reduction.watsup:128.1-130.37
  rule testop {c : c_numtype, c_1 : c_numtype, nt : numtype, testop : testop_numtype}:
    `%*~>%*`([CONST_admininstr(nt, c_1) TESTOP_admininstr(nt, testop)], [CONST_admininstr(I32_numtype, c)])
    -- if (c = $testop(testop, nt, c_1))

  ;; spec/6-reduction.watsup:132.1-134.40
  rule relop {c : c_numtype, c_1 : c_numtype, c_2 : c_numtype, nt : numtype, relop : relop_numtype}:
    `%*~>%*`([CONST_admininstr(nt, c_1) CONST_admininstr(nt, c_2) RELOP_admininstr(nt, relop)], [CONST_admininstr(I32_numtype, c)])
    -- if (c = $relop(relop, nt, c_1, c_2))

  ;; spec/6-reduction.watsup:137.1-138.70
  rule extend {c : c_numtype, n : n, nt : numtype}:
    `%*~>%*`([CONST_admininstr(nt, c) EXTEND_admininstr(nt, n)], [CONST_admininstr(nt, $ext(n, $size(nt <: valtype), S_sx, c))])

  ;; spec/6-reduction.watsup:141.1-143.48
  rule cvtop-val {c : c_numtype, c_1 : c_numtype, cvtop : cvtop, nt : numtype, nt_1 : numtype, nt_2 : numtype, sx? : sx?}:
    `%*~>%*`([CONST_admininstr(nt, c_1) CVTOP_admininstr(nt_1, cvtop, nt_2, sx?{sx})], [CONST_admininstr(nt, c)])
    -- if ($cvtop(nt_1, cvtop, nt_2, sx?{sx}, c_1) = [c])

  ;; spec/6-reduction.watsup:145.1-147.54
  rule cvtop-trap {c_1 : c_numtype, cvtop : cvtop, nt : numtype, nt_1 : numtype, nt_2 : numtype, sx? : sx?}:
    `%*~>%*`([CONST_admininstr(nt, c_1) CVTOP_admininstr(nt_1, cvtop, nt_2, sx?{sx})], [TRAP_admininstr])
    -- if ($cvtop(nt_1, cvtop, nt_2, sx?{sx}, c_1) = [])

  ;; spec/6-reduction.watsup:154.1-156.28
  rule ref.is_null-true {rt : reftype, val : val}:
    `%*~>%*`([(val <: admininstr) REF.IS_NULL_admininstr], [CONST_admininstr(I32_numtype, 1)])
    -- if (val = REF.NULL_val(rt))

  ;; spec/6-reduction.watsup:158.1-160.15
  rule ref.is_null-false {val : val}:
    `%*~>%*`([(val <: admininstr) REF.IS_NULL_admininstr], [CONST_admininstr(I32_numtype, 0)])
    -- otherwise

  ;; spec/6-reduction.watsup:169.1-170.47
  rule local.tee {val : val, x : idx}:
    `%*~>%*`([(val <: admininstr) LOCAL.TEE_admininstr(x)], [(val <: admininstr) (val <: admininstr) LOCAL.SET_admininstr(x)])

;; spec/6-reduction.watsup:5.1-5.63
relation Step_read: `%~>%*`(config, admininstr*)
  ;; spec/6-reduction.watsup:82.1-83.47
  rule call {x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CALL_admininstr(x)]), [CALL_ADDR_admininstr($funcaddr(z)[x])])

  ;; spec/6-reduction.watsup:85.1-88.34
  rule call_indirect-call {a : addr, ft : functype, func : func, i : nat, m : moduleinst, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, i) CALL_INDIRECT_admininstr(x, ft)]), [CALL_ADDR_admininstr(a)])
    -- if ($table(z, x)[i] = REF.FUNC_ADDR_ref(a))
    -- if ($funcinst(z)[a] = `%;%`(m, func))

  ;; spec/6-reduction.watsup:90.1-92.15
  rule call_indirect-trap {ft : functype, i : nat, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, i) CALL_INDIRECT_admininstr(x, ft)]), [TRAP_admininstr])
    -- otherwise

  ;; spec/6-reduction.watsup:94.1-97.52
  rule call_addr {a : addr, f : frame, instr* : instr*, k : nat, m : moduleinst, n : n, t* : valtype*, t_1^k : valtype^k, t_2^n : valtype^n, val^k : val^k, z : state}:
    `%~>%*`(`%;%*`(z, (val <: admininstr)^k{val} :: [CALL_ADDR_admininstr(a)]), [FRAME__admininstr(n, f, [LABEL__admininstr(n, [], (instr <: admininstr)*{instr})])])
    -- if ($funcinst(z)[a] = `%;%`(m, `FUNC%%*%`(`%->%`(t_1^k{t_1}, t_2^n{t_2}), t*{t}, instr*{instr})))
    -- if (f = {LOCAL val^k{val} :: $default_(t)*{t}, MODULE m})

  ;; spec/6-reduction.watsup:150.1-151.53
  rule ref.func {x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [REF.FUNC_admininstr(x)]), [REF.FUNC_ADDR_admininstr($funcaddr(z)[x])])

  ;; spec/6-reduction.watsup:163.1-164.37
  rule local.get {x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [LOCAL.GET_admininstr(x)]), [($local(z, x) <: admininstr)])

  ;; spec/6-reduction.watsup:173.1-174.39
  rule global.get {x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [GLOBAL.GET_admininstr(x)]), [($global(z, x) <: admininstr)])

  ;; spec/6-reduction.watsup:180.1-182.28
  rule table.get-trap {i : nat, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, i) TABLE.GET_admininstr(x)]), [TRAP_admininstr])
    -- if (i >= |$table(z, x)|)

  ;; spec/6-reduction.watsup:184.1-186.27
  rule table.get-val {i : nat, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, i) TABLE.GET_admininstr(x)]), [($table(z, x)[i] <: admininstr)])
    -- if (i < |$table(z, x)|)

  ;; spec/6-reduction.watsup:188.1-190.28
  rule table.set-trap {i : nat, ref : ref, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, i) (ref <: admininstr) TABLE.GET_admininstr(x)]), [TRAP_admininstr])
    -- if (i >= |$table(z, x)|)

  ;; spec/6-reduction.watsup:197.1-199.27
  rule table.size {n : n, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [TABLE.SIZE_admininstr(x)]), [CONST_admininstr(I32_numtype, n)])
    -- if (|$table(z, x)| = n)

  ;; spec/6-reduction.watsup:205.1-206.57
  rule table.grow-fail {n : n, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, n) TABLE.GROW_admininstr(x)]), [CONST_admininstr(I32_numtype, - 1)])

  ;; spec/6-reduction.watsup:209.1-211.34
  rule table.fill-trap {i : nat, n : n, val : val, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, i) (val <: admininstr) CONST_admininstr(I32_numtype, n) TABLE.FILL_admininstr(x)]), [TRAP_admininstr])
    -- if ((i + n) > |$table(z, x)|)

  ;; spec/6-reduction.watsup:213.1-216.14
  rule table.fill-zero {i : nat, n : n, val : val, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, i) (val <: admininstr) CONST_admininstr(I32_numtype, n) TABLE.FILL_admininstr(x)]), [])
    -- otherwise
    -- if (n = 0)

  ;; spec/6-reduction.watsup:218.1-222.15
  rule table.fill-succ {i : nat, n : n, val : val, x : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, i) (val <: admininstr) CONST_admininstr(I32_numtype, n) TABLE.FILL_admininstr(x)]), [CONST_admininstr(I32_numtype, i) (val <: admininstr) TABLE.SET_admininstr(x) CONST_admininstr(I32_numtype, (i + 1)) (val <: admininstr) CONST_admininstr(I32_numtype, (n - 1)) TABLE.FILL_admininstr(x)])
    -- otherwise

  ;; spec/6-reduction.watsup:225.1-227.63
  rule table.copy-trap {i : nat, j : nat, n : n, x : idx, y : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, j) CONST_admininstr(I32_numtype, i) CONST_admininstr(I32_numtype, n) TABLE.COPY_admininstr(x, y)]), [TRAP_admininstr])
    -- if (((i + n) > |$table(z, y)|) \/ ((j + n) > |$table(z, x)|))

  ;; spec/6-reduction.watsup:229.1-232.14
  rule table.copy-zero {i : nat, j : nat, n : n, x : idx, y : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, j) CONST_admininstr(I32_numtype, i) CONST_admininstr(I32_numtype, n) TABLE.COPY_admininstr(x, y)]), [])
    -- otherwise
    -- if (n = 0)

  ;; spec/6-reduction.watsup:234.1-239.15
  rule table.copy-le {i : nat, j : nat, n : n, x : idx, y : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, j) CONST_admininstr(I32_numtype, i) CONST_admininstr(I32_numtype, n) TABLE.COPY_admininstr(x, y)]), [CONST_admininstr(I32_numtype, j) CONST_admininstr(I32_numtype, i) TABLE.GET_admininstr(y) TABLE.SET_admininstr(x) CONST_admininstr(I32_numtype, (j + 1)) CONST_admininstr(I32_numtype, (i + 1)) CONST_admininstr(I32_numtype, (n - 1)) TABLE.COPY_admininstr(x, y)])
    -- otherwise
    -- if (j <= i)

  ;; spec/6-reduction.watsup:241.1-245.15
  rule table.copy-gt {i : nat, j : nat, n : n, x : idx, y : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, j) CONST_admininstr(I32_numtype, i) CONST_admininstr(I32_numtype, n) TABLE.COPY_admininstr(x, y)]), [CONST_admininstr(I32_numtype, ((j + n) - 1)) CONST_admininstr(I32_numtype, ((i + n) - 1)) TABLE.GET_admininstr(y) TABLE.SET_admininstr(x) CONST_admininstr(I32_numtype, (j + 1)) CONST_admininstr(I32_numtype, (i + 1)) CONST_admininstr(I32_numtype, (n - 1)) TABLE.COPY_admininstr(x, y)])
    -- otherwise

  ;; spec/6-reduction.watsup:248.1-250.62
  rule table.init-trap {i : nat, j : nat, n : n, x : idx, y : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, j) CONST_admininstr(I32_numtype, i) CONST_admininstr(I32_numtype, n) TABLE.INIT_admininstr(x, y)]), [TRAP_admininstr])
    -- if (((i + n) > |$elem(z, y)|) \/ ((j + n) > |$table(z, x)|))

  ;; spec/6-reduction.watsup:252.1-255.14
  rule table.init-zero {i : nat, j : nat, n : n, x : idx, y : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, j) CONST_admininstr(I32_numtype, i) CONST_admininstr(I32_numtype, n) TABLE.INIT_admininstr(x, y)]), [])
    -- otherwise
    -- if (n = 0)

  ;; spec/6-reduction.watsup:257.1-261.15
  rule table.init-succ {i : nat, j : nat, n : n, x : idx, y : idx, z : state}:
    `%~>%*`(`%;%*`(z, [CONST_admininstr(I32_numtype, j) CONST_admininstr(I32_numtype, i) CONST_admininstr(I32_numtype, n) TABLE.INIT_admininstr(x, y)]), [CONST_admininstr(I32_numtype, j) ($elem(z, y)[i] <: admininstr) TABLE.SET_admininstr(x) CONST_admininstr(I32_numtype, (j + 1)) CONST_admininstr(I32_numtype, (i + 1)) CONST_admininstr(I32_numtype, (n - 1)) TABLE.INIT_admininstr(x, y)])
    -- otherwise

;; spec/6-reduction.watsup:3.1-3.63
relation Step: `%~>%`(config, config)
  ;; spec/6-reduction.watsup:7.1-9.34
  rule pure {instr* : instr*, instr'* : instr*, z : state}:
    `%~>%`(`%;%*`(z, (instr <: admininstr)*{instr}), `%;%*`(z, (instr' <: admininstr)*{instr'}))
    -- Step_pure: `%*~>%*`((instr <: admininstr)*{instr}, (instr' <: admininstr)*{instr'})

  ;; spec/6-reduction.watsup:11.1-13.37
  rule read {instr* : instr*, instr'* : instr*, z : state}:
    `%~>%`(`%;%*`(z, (instr <: admininstr)*{instr}), `%;%*`(z, (instr' <: admininstr)*{instr'}))
    -- Step_read: `%~>%*`(`%;%*`(z, (instr <: admininstr)*{instr}), (instr' <: admininstr)*{instr'})

  ;; spec/6-reduction.watsup:166.1-167.60
  rule local.set {val : val, x : idx, z : state}:
    `%~>%`(`%;%*`(z, [(val <: admininstr) LOCAL.SET_admininstr(x)]), `%;%*`($with_local(z, x, val), []))

  ;; spec/6-reduction.watsup:176.1-177.62
  rule global.set {val : val, x : idx, z : state}:
    `%~>%`(`%;%*`(z, [(val <: admininstr) GLOBAL.SET_admininstr(x)]), `%;%*`($with_global(z, x, val), []))

  ;; spec/6-reduction.watsup:192.1-194.27
  rule table.set-val {i : nat, ref : ref, x : idx, z : state}:
    `%~>%`(`%;%*`(z, [CONST_admininstr(I32_numtype, i) (ref <: admininstr) TABLE.GET_admininstr(x)]), `%;%*`($with_table(z, x, i, ref), []))
    -- if (i < |$table(z, x)|)

  ;; spec/6-reduction.watsup:202.1-203.102
  rule table.grow-succeed {n : n, ref : ref, x : idx, z : state}:
    `%~>%`(`%;%*`(z, [(ref <: admininstr) CONST_admininstr(I32_numtype, n) TABLE.GROW_admininstr(x)]), `%;%*`($with_tableext(z, x, ref^n{}), [CONST_admininstr(I32_numtype, |$table(z, x)|)]))

  ;; spec/6-reduction.watsup:264.1-265.59
  rule elem.drop {x : idx, z : state}:
    `%~>%`(`%;%*`(z, [ELEM.DROP_admininstr(x)]), `%;%*`($with_elem(z, x, []), []))

$$
\begin{array}{@{}lrrl@{}}
& \mathit{n} &::=& \mathit{nat} \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}}
\mbox{(name)} & \mathit{name} &::=& \mathit{text} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}}
\mbox{(byte)} & \mathit{byte} &::=& \mathit{nat} \\
\mbox{(32-bit integer)} & \mathit{u{\scriptstyle32}} &::=& \mathit{nat} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}}
\mbox{(index)} & \mathit{idx} &::=& \mathit{nat} \\
\mbox{(function index)} & \mathit{funcidx} &::=& \mathit{idx} \\
\mbox{(global index)} & \mathit{globalidx} &::=& \mathit{idx} \\
\mbox{(table index)} & \mathit{tableidx} &::=& \mathit{idx} \\
\mbox{(memory index)} & \mathit{memidx} &::=& \mathit{idx} \\
\mbox{(elem index)} & \mathit{elemidx} &::=& \mathit{idx} \\
\mbox{(data index)} & \mathit{dataidx} &::=& \mathit{idx} \\
\mbox{(label index)} & \mathit{labelidx} &::=& \mathit{idx} \\
\mbox{(local index)} & \mathit{localidx} &::=& \mathit{idx} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}}
\mbox{(number type)} & \mathit{numtype} &::=& \mathsf{i{\scriptstyle32}} ~|~ \mathsf{i{\scriptstyle64}} ~|~ \mathsf{f{\scriptstyle32}} ~|~ \mathsf{f{\scriptstyle64}} \\
\mbox{(vector type)} & \mathit{vectype} &::=& \mathsf{v{\scriptstyle128}} \\
\mbox{(reference type)} & \mathit{reftype} &::=& \mathsf{funcref} ~|~ \mathsf{externref} \\
\mbox{(value type)} & \mathit{valtype} &::=& \mathit{numtype} ~|~ \mathit{vectype} ~|~ \mathit{reftype} ~|~ \mathsf{bot} \\
& {\mathsf{i}}{\mathit{n}} &::=& \mathsf{i{\scriptstyle32}} ~|~ \mathsf{i{\scriptstyle64}} \\
& {\mathsf{f}}{\mathit{n}} &::=& \mathsf{f{\scriptstyle32}} ~|~ \mathsf{f{\scriptstyle64}} \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}}
\mbox{(result type)} & \mathit{resulttype} &::=& {\mathit{valtype}^\ast} \\
\mbox{(limits)} & \mathit{limits} &::=& [\mathit{u{\scriptstyle32}} .. \mathit{u{\scriptstyle32}}] \\
\mbox{(global type)} & \mathit{globaltype} &::=& {\mathsf{mut}^?}~\mathit{valtype} \\
\mbox{(function type)} & \mathit{functype} &::=& \mathit{resulttype} \rightarrow \mathit{resulttype} \\
\mbox{(table type)} & \mathit{tabletype} &::=& \mathit{limits}~\mathit{reftype} \\
\mbox{(memory type)} & \mathit{memtype} &::=& \mathit{limits}~\mathsf{i{\scriptstyle8}} \\
\mbox{(element type)} & \mathit{elemtype} &::=& \mathit{reftype} \\
\mbox{(data type)} & \mathit{datatype} &::=& \mathsf{ok} \\
\mbox{(external type)} & \mathit{externtype} &::=& \mathsf{global}~\mathit{globaltype} ~|~ \mathsf{func}~\mathit{functype} ~|~ \mathsf{table}~\mathit{tabletype} ~|~ \mathsf{memory}~\mathit{memtype} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}}
\mbox{(signedness)} & \mathit{sx} &::=& \mathsf{u} ~|~ \mathsf{s} \\
& \mathit{unop}_{\mathsf{ixx}} &::=& \mathsf{clz} ~|~ \mathsf{ctz} ~|~ \mathsf{popcnt} \\
& \mathit{unop}_{\mathsf{fxx}} &::=& \mathsf{abs} ~|~ \mathsf{neg} ~|~ \mathsf{sqrt} ~|~ \mathsf{ceil} ~|~ \mathsf{floor} ~|~ \mathsf{trunc} ~|~ \mathsf{nearest} \\
& \mathit{binop}_{\mathsf{ixx}} &::=& \mathsf{add} ~|~ \mathsf{sub} ~|~ \mathsf{mul} ~|~ {\mathsf{div\_}}{\mathsf{\mathit{sx}}} ~|~ {\mathsf{rem\_}}{\mathsf{\mathit{sx}}} \\ &&|&
\mathsf{and} ~|~ \mathsf{or} ~|~ \mathsf{xor} ~|~ \mathsf{shl} ~|~ {\mathsf{shr\_}}{\mathsf{\mathit{sx}}} ~|~ \mathsf{rotl} ~|~ \mathsf{rotr} \\
& \mathit{binop}_{\mathsf{fxx}} &::=& \mathsf{add} ~|~ \mathsf{sub} ~|~ \mathsf{mul} ~|~ \mathsf{div} ~|~ \mathsf{min} ~|~ \mathsf{max} ~|~ \mathsf{copysign} \\
& \mathit{testop}_{\mathsf{ixx}} &::=& \mathsf{eqz} \\
& \mathit{testop}_{\mathsf{fxx}} &::=&  \\
& \mathit{relop}_{\mathsf{ixx}} &::=& \mathsf{eq} ~|~ \mathsf{ne} ~|~ {\mathsf{lt\_}}{\mathsf{\mathit{sx}}} ~|~ {\mathsf{gt\_}}{\mathsf{\mathit{sx}}} ~|~ {\mathsf{le\_}}{\mathsf{\mathit{sx}}} ~|~ {\mathsf{ge\_}}{\mathsf{\mathit{sx}}} \\
& \mathit{relop}_{\mathsf{fxx}} &::=& \mathsf{eq} ~|~ \mathsf{ne} ~|~ \mathsf{lt} ~|~ \mathsf{gt} ~|~ \mathsf{le} ~|~ \mathsf{ge} \\
& \mathit{unop}_{\mathit{numtype}} &::=& \mathit{unop}_{\mathsf{ixx}} ~|~ \mathit{unop}_{\mathsf{fxx}} \\
& \mathit{binop}_{\mathit{numtype}} &::=& \mathit{binop}_{\mathsf{ixx}} ~|~ \mathit{binop}_{\mathsf{fxx}} \\
& \mathit{testop}_{\mathit{numtype}} &::=& \mathit{testop}_{\mathsf{ixx}} ~|~ \mathit{testop}_{\mathsf{fxx}} \\
& \mathit{relop}_{\mathit{numtype}} &::=& \mathit{relop}_{\mathsf{ixx}} ~|~ \mathit{relop}_{\mathsf{fxx}} \\
& \mathit{cvtop} &::=& \mathsf{convert} ~|~ \mathsf{reinterpret} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}}
& \mathit{c}_{\mathit{numtype}} &::=& \mathit{nat} \\
& \mathit{c}_{\mathit{vectype}} &::=& \mathit{nat} \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}}
\mbox{(block type)} & \mathit{blocktype} &::=& \mathit{functype} \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}}
& \mathit{instr} &::=& \mathsf{unreachable} \\ &&|&
\mathsf{nop} \\ &&|&
\mathsf{drop} \\ &&|&
\mathsf{select}~{\mathit{valtype}^?} \\ &&|&
\mathsf{block}~\mathit{blocktype}~{\mathit{instr}^\ast} \\ &&|&
\mathsf{loop}~\mathit{blocktype}~{\mathit{instr}^\ast} \\ &&|&
\mathsf{if}~\mathit{blocktype}~{\mathit{instr}^\ast}~\mathsf{else}~{\mathit{instr}^\ast} \\ &&|&
\mathsf{br}~\mathit{labelidx} \\ &&|&
\mathsf{br\_if}~\mathit{labelidx} \\ &&|&
\mathsf{br\_table}~{\mathit{labelidx}^\ast}~\mathit{labelidx} \\ &&|&
\mathsf{call}~\mathit{funcidx} \\ &&|&
\mathsf{call\_indirect}~\mathit{tableidx}~\mathit{functype} \\ &&|&
\mathsf{return} \\ &&|&
\mathsf{\mathit{numtype}}.\mathsf{const}~\mathsf{\mathit{c}\_{\mathit{numtype}}} \\ &&|&
\mathsf{\mathit{numtype}} . \mathsf{\mathit{unop}\_{\mathit{numtype}}} \\ &&|&
\mathsf{\mathit{numtype}} . \mathsf{\mathit{binop}\_{\mathit{numtype}}} \\ &&|&
\mathsf{\mathit{numtype}} . \mathsf{\mathit{testop}\_{\mathit{numtype}}} \\ &&|&
\mathsf{\mathit{numtype}} . \mathsf{\mathit{relop}\_{\mathit{numtype}}} \\ &&|&
{\mathsf{\mathit{numtype}}.\mathsf{extend}}{\mathsf{\mathit{n}}} \\ &&|&
\mathsf{\mathit{numtype}} . {{{{\mathsf{\mathit{cvtop}}}{\mathsf{\_}}}{\mathsf{\mathit{numtype}}}}{\mathsf{\_}}}{\mathsf{{\mathit{sx}^?}}} \\ &&|&
\mathsf{ref.null}~\mathit{reftype} \\ &&|&
\mathsf{ref.func}~\mathit{funcidx} \\ &&|&
\mathsf{ref.is\_null} \\ &&|&
\mathsf{local.get}~\mathit{localidx} \\ &&|&
\mathsf{local.set}~\mathit{localidx} \\ &&|&
\mathsf{local.tee}~\mathit{localidx} \\ &&|&
\mathsf{global.get}~\mathit{globalidx} \\ &&|&
\mathsf{global.set}~\mathit{globalidx} \\ &&|&
\mathsf{table.get}~\mathit{tableidx} \\ &&|&
\mathsf{table.set}~\mathit{tableidx} \\ &&|&
\mathsf{table.size}~\mathit{tableidx} \\ &&|&
\mathsf{table.grow}~\mathit{tableidx} \\ &&|&
\mathsf{table.fill}~\mathit{tableidx} \\ &&|&
\mathsf{table.copy}~\mathit{tableidx}~\mathit{tableidx} \\ &&|&
\mathsf{table.init}~\mathit{tableidx}~\mathit{elemidx} \\ &&|&
\mathsf{elem.drop}~\mathit{elemidx} \\ &&|&
\mathsf{memory.size} \\ &&|&
\mathsf{memory.grow} \\ &&|&
\mathsf{memory.fill} \\ &&|&
\mathsf{memory.copy} \\ &&|&
\mathsf{memory.init}~\mathit{dataidx} \\ &&|&
\mathsf{data.drop}~\mathit{dataidx} \\ &&|&
{\mathsf{\mathit{numtype}}.\mathsf{load}}{\mathsf{{(\mathit{n}~\mathit{sx})^?}}~\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}} \\ &&|&
{\mathsf{\mathit{numtype}}.\mathsf{store}}{\mathsf{{\mathit{n}^?}}~\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}} \\
\mbox{(expression)} & \mathit{expr} &::=& {\mathit{instr}^\ast} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}}
& \mathit{elemmode} &::=& \mathsf{table}~\mathit{tableidx}~\mathit{expr} ~|~ \mathsf{declare} \\
& \mathit{datamode} &::=& \mathsf{memory}~\mathit{memidx}~\mathit{expr} \\
\mbox{(function)} & \mathit{func} &::=& \mathsf{func}~\mathit{functype}~{\mathit{valtype}^\ast}~\mathit{expr} \\
\mbox{(global)} & \mathit{global} &::=& \mathsf{global}~\mathit{globaltype}~\mathit{expr} \\
\mbox{(table)} & \mathit{table} &::=& \mathsf{table}~\mathit{tabletype} \\
\mbox{(memory)} & \mathit{mem} &::=& \mathsf{memory}~\mathit{memtype} \\
\mbox{(table segment)} & \mathit{elem} &::=& \mathsf{elem}~\mathit{reftype}~{\mathit{expr}^\ast}~{\mathit{elemmode}^?} \\
\mbox{(memory segment)} & \mathit{data} &::=& \mathsf{data}~{({\mathit{byte}^\ast})^\ast}~{\mathit{datamode}^?} \\
\mbox{(start function)} & \mathit{start} &::=& \mathsf{start}~\mathit{funcidx} \\
\mbox{(external use)} & \mathit{externuse} &::=& \mathsf{func}~\mathit{funcidx} ~|~ \mathsf{global}~\mathit{globalidx} ~|~ \mathsf{table}~\mathit{tableidx} ~|~ \mathsf{memory}~\mathit{memidx} \\
\mbox{(export)} & \mathit{export} &::=& \mathsf{export}~\mathit{name}~\mathit{externuse} \\
\mbox{(import)} & \mathit{import} &::=& \mathsf{import}~\mathit{name}~\mathit{name}~\mathit{externtype} \\
\mbox{(module)} & \mathit{module} &::=& \mathsf{module}~{\mathit{import}^\ast}~{\mathit{func}^\ast}~{\mathit{global}^\ast}~{\mathit{table}^\ast}~{\mathit{mem}^\ast}~{\mathit{elem}^\ast}~{\mathit{data}^\ast}~{\mathit{start}^\ast}~{\mathit{export}^\ast} \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
{|\mathsf{i{\scriptstyle32}}|} &=& 32 &  \\
{|\mathsf{i{\scriptstyle64}}|} &=& 64 &  \\
{|\mathsf{f{\scriptstyle32}}|} &=& 32 &  \\
{|\mathsf{f{\scriptstyle64}}|} &=& 64 &  \\
{|\mathsf{v{\scriptstyle128}}|} &=& 128 &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lcl@{}l@{}}
\mathrm{test}_{\mathit{sub}_{\mathsf{atom}_{22}}}(\mathit{n}_{3_{\mathsf{atom}_{\mathit{y}}}}) &=& 0 &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
{\mathrm{curried}}_{\mathit{n}_{1}}(\mathit{n}_{2}) &=& \mathit{n}_{1} + \mathit{n}_{2} &  \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}}
& \mathit{testfuse} &::=& {\mathsf{ab}}_{\mathit{nat}}\,\,\mathit{nat}~\mathit{nat} \\ &&|&
{\mathsf{cd}}_{\mathsf{\mathit{nat}}}\,\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}} \\ &&|&
{\mathsf{ef\_}}{\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}} \\ &&|&
{{\mathsf{gh}}_{\mathsf{\mathit{nat}}}}{\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}} \\ &&|&
{{\mathsf{ij}}_{\mathsf{\mathit{nat}}}}{\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}} \\ &&|&
{\mathsf{kl\_ab}}{\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}} \\ &&|&
{\mathsf{mn\_}}{\mathsf{ab}~\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}} \\ &&|&
{{\mathsf{op\_}}{\mathsf{ab}}}{\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}} \\ &&|&
{{\mathsf{qr}}_{\mathsf{\mathit{nat}}}}{\mathsf{ab}~\mathsf{\mathit{nat}}~\mathsf{\mathit{nat}}} \\
\mbox{(address)} & \mathit{addr} &::=& \mathit{nat} \\
\mbox{(function address)} & \mathit{funcaddr} &::=& \mathit{addr} \\
\mbox{(global address)} & \mathit{globaladdr} &::=& \mathit{addr} \\
\mbox{(table address)} & \mathit{tableaddr} &::=& \mathit{addr} \\
\mbox{(memory address)} & \mathit{memaddr} &::=& \mathit{addr} \\
\mbox{(elem address)} & \mathit{elemaddr} &::=& \mathit{addr} \\
\mbox{(data address)} & \mathit{dataaddr} &::=& \mathit{addr} \\
\mbox{(label address)} & \mathit{labeladdr} &::=& \mathit{addr} \\
\mbox{(host address)} & \mathit{hostaddr} &::=& \mathit{addr} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}}
\mbox{(number)} & \mathit{num} &::=& \mathsf{\mathit{numtype}}.\mathsf{const}~\mathsf{\mathit{c}\_{\mathit{numtype}}} \\
\mbox{(reference)} & \mathit{ref} &::=& \mathsf{ref.null}~\mathit{reftype} ~|~ \mathsf{ref.func}~\mathsf{\mathit{funcaddr}} ~|~ \mathsf{ref.extern}~\mathsf{\mathit{hostaddr}} \\
\mbox{(value)} & \mathit{val} &::=& \mathit{num} ~|~ \mathit{ref} \\
\mbox{(result)} & \mathit{result} &::=& {\mathit{val}^\ast} ~|~ \mathsf{trap} \\
\end{array}
$$

$$
\begin{array}{@{}lrrl@{}}
\mbox{(external value)} & \mathit{externval} &::=& \mathsf{func}~\mathit{funcaddr} ~|~ \mathsf{global}~\mathit{globaladdr} ~|~ \mathsf{table}~\mathit{tableaddr} ~|~ \mathsf{mem}~\mathit{memaddr} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lcl@{}l@{}}
{\mathrm{default}}_{\mathsf{i{\scriptstyle32}}} &=& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~0) &  \\
{\mathrm{default}}_{\mathsf{i{\scriptstyle64}}} &=& (\mathsf{i{\scriptstyle64}}.\mathsf{const}~0) &  \\
{\mathrm{default}}_{\mathsf{f{\scriptstyle32}}} &=& (\mathsf{f{\scriptstyle32}}.\mathsf{const}~0) &  \\
{\mathrm{default}}_{\mathsf{f{\scriptstyle64}}} &=& (\mathsf{f{\scriptstyle64}}.\mathsf{const}~0) &  \\
{\mathrm{default}}_{\mathit{rt}} &=& (\mathsf{ref.null}~\mathit{rt}) &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}}
\mbox{(function instance)} & \mathit{funcinst} &::=& \mathit{moduleinst} ; \mathit{func} \\
\mbox{(global instance)} & \mathit{globalinst} &::=& \mathit{val} \\
\mbox{(table instance)} & \mathit{tableinst} &::=& {\mathit{ref}^\ast} \\
\mbox{(memory instance)} & \mathit{meminst} &::=& {\mathit{byte}^\ast} \\
\mbox{(element instance)} & \mathit{eleminst} &::=& {\mathit{ref}^\ast} \\
\mbox{(data instance)} & \mathit{datainst} &::=& {\mathit{byte}^\ast} \\
\mbox{(export instance)} & \mathit{exportinst} &::=& \mathsf{export}~\mathit{name}~\mathit{externval} \\
\mbox{(store)} & \mathit{store} &::=& \{\; \begin{array}[t]{@{}l@{}}
\mathsf{func}~{\mathit{funcinst}^\ast},\; \\
  \mathsf{global}~{\mathit{globalinst}^\ast},\; \\
  \mathsf{table}~{\mathit{tableinst}^\ast},\; \\
  \mathsf{mem}~{\mathit{meminst}^\ast},\; \\
  \mathsf{elem}~{\mathit{eleminst}^\ast},\; \\
  \mathsf{data}~{\mathit{datainst}^\ast} \;\}\end{array} \\
\mbox{(module instance)} & \mathit{moduleinst} &::=& \{\; \begin{array}[t]{@{}l@{}}
\mathsf{func}~{\mathit{funcaddr}^\ast},\; \\
  \mathsf{global}~{\mathit{globaladdr}^\ast},\; \\
  \mathsf{table}~{\mathit{tableaddr}^\ast},\; \\
  \mathsf{mem}~{\mathit{memaddr}^\ast},\; \\
  \mathsf{elem}~{\mathit{elemaddr}^\ast},\; \\
  \mathsf{data}~{\mathit{dataaddr}^\ast},\; \\
  \mathsf{export}~{\mathit{exportinst}^\ast} \;\}\end{array} \\
\mbox{(frame)} & \mathit{frame} &::=& \{\; \begin{array}[t]{@{}l@{}}
\mathsf{local}~{\mathit{val}^\ast},\; \\
  \mathsf{module}~\mathit{moduleinst} \;\}\end{array} \\
\mbox{(state)} & \mathit{state} &::=& \mathit{store} ; \mathit{frame} \\
\mbox{(configuration)} & \mathit{config} &::=& \mathit{state} ; {\mathit{instr}^\ast} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lcl@{}l@{}}
(\mathit{s} ; \mathit{f}).\mathsf{module}.\mathsf{func} &=& \mathit{f}.\mathsf{module}.\mathsf{func} &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
(\mathit{s} ; \mathit{f}).\mathsf{func} &=& \mathit{s}.\mathsf{func} &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
{(\mathit{s} ; \mathit{f}).\mathsf{func}}{[\mathit{x}]} &=& \mathit{s}.\mathsf{func}[\mathit{f}.\mathsf{module}.\mathsf{func}[\mathit{x}]] &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
{(\mathit{s} ; \mathit{f}).\mathsf{global}}{[\mathit{x}]} &=& \mathit{s}.\mathsf{global}[\mathit{f}.\mathsf{module}.\mathsf{global}[\mathit{x}]] &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
{(\mathit{s} ; \mathit{f}).\mathsf{table}}{[\mathit{x}]} &=& \mathit{s}.\mathsf{table}[\mathit{f}.\mathsf{module}.\mathsf{table}[\mathit{x}]] &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
{(\mathit{s} ; \mathit{f}).\mathsf{mem}}{[\mathit{x}]} &=& \mathit{s}.\mathsf{mem}[\mathit{f}.\mathsf{module}.\mathsf{mem}[\mathit{x}]] &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
{(\mathit{s} ; \mathit{f}).\mathsf{elem}}{[\mathit{x}]} &=& \mathit{s}.\mathsf{elem}[\mathit{f}.\mathsf{module}.\mathsf{elem}[\mathit{x}]] &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
{(\mathit{s} ; \mathit{f}).\mathsf{data}}{[\mathit{x}]} &=& \mathit{s}.\mathsf{data}[\mathit{f}.\mathsf{module}.\mathsf{data}[\mathit{x}]] &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
{(\mathit{s} ; \mathit{f}).\mathsf{local}}{[\mathit{x}]} &=& \mathit{f}.\mathsf{local}[\mathit{x}] &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lcl@{}l@{}}
(\mathit{s} ; \mathit{f})[\mathsf{local}[\mathit{x}] = \mathit{v}] &=& \mathit{s} ; \mathit{f}[\mathsf{local}[\mathit{x}] = \mathit{v}] &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
(\mathit{s} ; \mathit{f})[\mathsf{global}[\mathit{x}] = \mathit{v}] &=& \mathit{s}[\mathsf{global}[\mathit{f}.\mathsf{module}.\mathsf{global}[\mathit{x}]] = \mathit{v}] ; \mathit{f} &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
(\mathit{s} ; \mathit{f})[\mathsf{table}[\mathit{x}][\mathit{i}] = \mathit{r}] &=& \mathit{s}[\mathsf{table}[\mathit{f}.\mathsf{module}.\mathsf{table}[\mathit{x}]][\mathit{i}] = \mathit{r}] ; \mathit{f} &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
(\mathit{s} ; \mathit{f})[\mathsf{table}[\mathit{x}] = ..{\mathit{r}^\ast}] &=& \mathit{s}[\mathsf{table}[\mathit{f}.\mathsf{module}.\mathsf{table}[\mathit{x}]] = ..{\mathit{r}^\ast}] ; \mathit{f} &  \\
\end{array}
$$

$$
\begin{array}{@{}lcl@{}l@{}}
(\mathit{s} ; \mathit{f})[\mathsf{elem}[\mathit{x}] = {\mathit{r}^\ast}] &=& \mathit{s}[\mathsf{table}[\mathit{f}.\mathsf{module}.\mathsf{table}[\mathit{x}]] = {\mathit{r}^\ast}] ; \mathit{f} &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}lrrl@{}}
\mbox{(administrative instruction)} & \mathit{instr} &::=& \mathit{instr} \\ &&|&
\mathsf{ref.func}~\mathsf{\mathit{funcaddr}} \\ &&|&
\mathsf{ref.extern}~\mathsf{\mathit{hostaddr}} \\ &&|&
\mathsf{call}~\mathsf{\mathit{funcaddr}} \\ &&|&
{{\mathsf{label}}_{\mathsf{\mathit{n}}}}{\mathsf{\{{\mathit{instr}^\ast}\}}~\mathsf{{\mathit{instr}^\ast}}} \\ &&|&
{{\mathsf{frame}}_{\mathsf{\mathit{n}}}}{\mathsf{\{\mathit{frame}\}}~\mathsf{{\mathit{instr}^\ast}}} \\ &&|&
\mathsf{trap} \\
\mbox{(evaluation context)} & \mathit{E} &::=& [\mathsf{\_}] \\ &&|&
{\mathit{val}^\ast}~\mathit{E}~{\mathit{instr}^\ast} \\ &&|&
{{\mathsf{label}}_{\mathsf{\mathit{n}}}}{\mathsf{\{{\mathit{instr}^\ast}\}}~\mathsf{\mathit{e}}} \\
\end{array}
$$

$\boxed{\mathit{config} \hookrightarrow \mathit{config}}$

$\boxed{{\mathit{instr}^\ast} \hookrightarrow {\mathit{instr}^\ast}}$

$\boxed{\mathit{config} \hookrightarrow {\mathit{instr}^\ast}}$

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}pure}]} \quad & \mathit{z} ; {\mathit{instr}^\ast} &\hookrightarrow& \mathit{z} ; {{\mathit{instr}'}^\ast} &\quad
  \mbox{if}~{\mathit{instr}^\ast} \hookrightarrow {{\mathit{instr}'}^\ast} \\
{[\textsc{\scriptsize E{-}read}]} \quad & \mathit{z} ; {\mathit{instr}^\ast} &\hookrightarrow& \mathit{z} ; {{\mathit{instr}'}^\ast} &\quad
  \mbox{if}~\mathit{z} ; {\mathit{instr}^\ast} \hookrightarrow {{\mathit{instr}'}^\ast} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}unreachable}]} \quad & \mathsf{unreachable} &\hookrightarrow& \mathsf{trap} &  \\
{[\textsc{\scriptsize E{-}nop}]} \quad & \mathsf{nop} &\hookrightarrow& \epsilon &  \\
{[\textsc{\scriptsize E{-}drop}]} \quad & \mathit{val}~\mathsf{drop} &\hookrightarrow& \epsilon &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}select{-}true}]} \quad & \mathit{val}_{1}~\mathit{val}_{2}~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{c})~(\mathsf{select}~{\mathit{t}^?}) &\hookrightarrow& \mathit{val}_{1} &\quad
  \mbox{if}~\mathit{c} \neq 0 \\
{[\textsc{\scriptsize E{-}select{-}false}]} \quad & \mathit{val}_{1}~\mathit{val}_{2}~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{c})~(\mathsf{select}~{\mathit{t}^?}) &\hookrightarrow& \mathit{val}_{2} &\quad
  \mbox{if}~\mathit{c} = 0 \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}block}]} \quad & {\mathit{val}^{\mathit{k}}}~(\mathsf{block}~\mathit{bt}~{\mathit{instr}^\ast}) &\hookrightarrow& ({{\mathsf{label}}_{\mathit{n}}}{\{\epsilon\}~{\mathit{val}^{\mathit{k}}}~{\mathit{instr}^\ast}}) &\quad
  \mbox{if}~\mathit{bt} = {\mathit{t}_{1}^{\mathit{k}}} \rightarrow {\mathit{t}_{2}^{\mathit{n}}} \\
{[\textsc{\scriptsize E{-}loop}]} \quad & {\mathit{val}^{\mathit{k}}}~(\mathsf{loop}~\mathit{bt}~{\mathit{instr}^\ast}) &\hookrightarrow& ({{\mathsf{label}}_{\mathit{n}}}{\{\mathsf{loop}~\mathit{bt}~{\mathit{instr}^\ast}\}~{\mathit{val}^{\mathit{k}}}~{\mathit{instr}^\ast}}) &\quad
  \mbox{if}~\mathit{bt} = {\mathit{t}_{1}^{\mathit{k}}} \rightarrow {\mathit{t}_{2}^{\mathit{n}}} \\
{[\textsc{\scriptsize E{-}if{-}true}]} \quad & (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{c})~(\mathsf{if}~\mathit{bt}~{\mathit{instr}_{1}^\ast}~\mathsf{else}~{\mathit{instr}_{2}^\ast}) &\hookrightarrow& (\mathsf{block}~\mathit{bt}~{\mathit{instr}_{1}^\ast}) &\quad
  \mbox{if}~\mathit{c} \neq 0 \\
{[\textsc{\scriptsize E{-}if{-}false}]} \quad & (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{c})~(\mathsf{if}~\mathit{bt}~{\mathit{instr}_{1}^\ast}~\mathsf{else}~{\mathit{instr}_{2}^\ast}) &\hookrightarrow& (\mathsf{block}~\mathit{bt}~{\mathit{instr}_{2}^\ast}) &\quad
  \mbox{if}~\mathit{c} = 0 \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}label{-}vals}]} \quad & ({{\mathsf{label}}_{\mathit{n}}}{\{{\mathit{instr}^\ast}\}~{\mathit{val}^\ast}}) &\hookrightarrow& {\mathit{val}^\ast} &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}br{-}zero}]} \quad & ({{\mathsf{label}}_{\mathit{n}}}{\{{{\mathit{instr}'}^\ast}\}~{{\mathit{val}'}^\ast}~{\mathit{val}^{\mathit{n}}}~(\mathsf{br}~0)~{\mathit{instr}^\ast}}) &\hookrightarrow& {\mathit{val}^{\mathit{n}}}~{{\mathit{instr}'}^\ast} &  \\
{[\textsc{\scriptsize E{-}br{-}succ}]} \quad & ({{\mathsf{label}}_{\mathit{n}}}{\{{{\mathit{instr}'}^\ast}\}~{\mathit{val}^\ast}~(\mathsf{br}~\mathit{l} + 1)~{\mathit{instr}^\ast}}) &\hookrightarrow& {\mathit{val}^\ast}~(\mathsf{br}~\mathit{l}) &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}br\_if{-}true}]} \quad & (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{c})~(\mathsf{br\_if}~\mathit{l}) &\hookrightarrow& (\mathsf{br}~\mathit{l}) &\quad
  \mbox{if}~\mathit{c} \neq 0 \\
{[\textsc{\scriptsize E{-}br\_if{-}false}]} \quad & (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{c})~(\mathsf{br\_if}~\mathit{l}) &\hookrightarrow& \epsilon &\quad
  \mbox{if}~\mathit{c} = 0 \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}br\_table{-}lt}]} \quad & (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{br\_table}~{\mathit{l}^\ast}~{\mathit{l}'}) &\hookrightarrow& (\mathsf{br}~{\mathit{l}^\ast}[\mathit{i}]) &\quad
  \mbox{if}~\mathit{i} < {|{\mathit{l}^\ast}|} \\
{[\textsc{\scriptsize E{-}br\_table{-}ge}]} \quad & (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{br\_table}~{\mathit{l}^\ast}~{\mathit{l}'}) &\hookrightarrow& (\mathsf{br}~{\mathit{l}'}) &\quad
  \mbox{if}~\mathit{i} \geq {|{\mathit{l}^\ast}|} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}call}]} \quad & \mathit{z} ; (\mathsf{call}~\mathit{x}) &\hookrightarrow& (\mathsf{call}~\mathit{z}.\mathsf{module}.\mathsf{func}[\mathit{x}]) &  \\
{[\textsc{\scriptsize E{-}call\_indirect{-}call}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{call\_indirect}~\mathit{x}~\mathit{ft}) &\hookrightarrow& (\mathsf{call}~\mathit{a}) &\quad
  \mbox{if}~{\mathit{z}.\mathsf{table}}{[\mathit{x}]}[\mathit{i}] = (\mathsf{ref.func}~\mathit{a}) \\
 &&&&\quad {\land}~\mathit{z}.\mathsf{func}[\mathit{a}] = \mathit{m} ; \mathit{func} \\
{[\textsc{\scriptsize E{-}call\_indirect{-}trap}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{call\_indirect}~\mathit{x}~\mathit{ft}) &\hookrightarrow& \mathsf{trap} &\quad
  \mbox{otherwise} \\
{[\textsc{\scriptsize E{-}call\_addr}]} \quad & \mathit{z} ; {\mathit{val}^{\mathit{k}}}~(\mathsf{call}~\mathit{a}) &\hookrightarrow& ({{\mathsf{frame}}_{\mathit{n}}}{\{\mathit{f}\}~({{\mathsf{label}}_{\mathit{n}}}{\{\epsilon\}~{\mathit{instr}^\ast}})}) &\quad
  \mbox{if}~\mathit{z}.\mathsf{func}[\mathit{a}] = \mathit{m} ; \mathsf{func}~({\mathit{t}_{1}^{\mathit{k}}} \rightarrow {\mathit{t}_{2}^{\mathit{n}}})~{\mathit{t}^\ast}~{\mathit{instr}^\ast} \\
 &&&&\quad {\land}~\mathit{f} = \{ \begin{array}[t]{@{}l@{}}
\mathsf{local}~{\mathit{val}^{\mathit{k}}}~{({\mathrm{default}}_{\mathit{t}})^\ast},\; \mathsf{module}~\mathit{m} \}\end{array} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}frame{-}vals}]} \quad & ({{\mathsf{frame}}_{\mathit{n}}}{\{\mathit{f}\}~{\mathit{val}^{\mathit{n}}}}) &\hookrightarrow& {\mathit{val}^{\mathit{n}}} &  \\
{[\textsc{\scriptsize E{-}return{-}frame}]} \quad & ({{\mathsf{frame}}_{\mathit{n}}}{\{\mathit{f}\}~{{\mathit{val}'}^\ast}~{\mathit{val}^{\mathit{n}}}~\mathsf{return}~{\mathit{instr}^\ast}}) &\hookrightarrow& {\mathit{val}^{\mathit{n}}} &  \\
{[\textsc{\scriptsize E{-}return{-}label}]} \quad & ({{\mathsf{label}}_{\mathit{k}}}{\{{{\mathit{instr}'}^\ast}\}~{\mathit{val}^\ast}~\mathsf{return}~{\mathit{instr}^\ast}}) &\hookrightarrow& {\mathit{val}^\ast}~\mathsf{return} &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}unop{-}val}]} \quad & (\mathit{nt}.\mathsf{const}~\mathit{c}_{1})~(\mathit{nt} . \mathit{unop}) &\hookrightarrow& (\mathit{nt}.\mathsf{const}~\mathit{c}) &\quad
  \mbox{if}~{\mathit{unop}}{{\mathsf{}}_{\mathit{nt}}\,(\mathit{c}_{1})} = \mathit{c} \\
{[\textsc{\scriptsize E{-}unop{-}trap}]} \quad & (\mathit{nt}.\mathsf{const}~\mathit{c}_{1})~(\mathit{nt} . \mathit{unop}) &\hookrightarrow& \mathsf{trap} &\quad
  \mbox{if}~{\mathit{unop}}{{\mathsf{}}_{\mathit{nt}}\,(\mathit{c}_{1})} = \epsilon \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}binop{-}val}]} \quad & (\mathit{nt}.\mathsf{const}~\mathit{c}_{1})~(\mathit{nt}.\mathsf{const}~\mathit{c}_{2})~(\mathit{nt} . \mathit{binop}) &\hookrightarrow& (\mathit{nt}.\mathsf{const}~\mathit{c}) &\quad
  \mbox{if}~{\mathit{binop}}{{\mathsf{}}_{\mathit{nt}}\,(\mathit{c}_{1},\, \mathit{c}_{2})} = \mathit{c} \\
{[\textsc{\scriptsize E{-}binop{-}trap}]} \quad & (\mathit{nt}.\mathsf{const}~\mathit{c}_{1})~(\mathit{nt}.\mathsf{const}~\mathit{c}_{2})~(\mathit{nt} . \mathit{binop}) &\hookrightarrow& \mathsf{trap} &\quad
  \mbox{if}~{\mathit{binop}}{{\mathsf{}}_{\mathit{nt}}\,(\mathit{c}_{1},\, \mathit{c}_{2})} = \epsilon \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}testop}]} \quad & (\mathit{nt}.\mathsf{const}~\mathit{c}_{1})~(\mathit{nt} . \mathit{testop}) &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{c}) &\quad
  \mbox{if}~\mathit{c} = {\mathit{testop}}{{\mathsf{}}_{\mathit{nt}}\,(\mathit{c}_{1})} \\
{[\textsc{\scriptsize E{-}relop}]} \quad & (\mathit{nt}.\mathsf{const}~\mathit{c}_{1})~(\mathit{nt}.\mathsf{const}~\mathit{c}_{2})~(\mathit{nt} . \mathit{relop}) &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{c}) &\quad
  \mbox{if}~\mathit{c} = {\mathit{relop}}{{\mathsf{}}_{\mathit{nt}}\,(\mathit{c}_{1},\, \mathit{c}_{2})} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}extend}]} \quad & (\mathit{nt}.\mathsf{const}~\mathit{c})~({\mathit{nt}.\mathsf{extend}}{\mathit{n}}) &\hookrightarrow& (\mathit{nt}.\mathsf{const}~{{\mathrm{ext}}_{\mathit{n}}({|\mathit{nt}|})^{\mathsf{s}}}~(\mathit{c})) &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}cvtop{-}val}]} \quad & (\mathit{nt}.\mathsf{const}~\mathit{c}_{1})~(\mathit{nt}_{1} . {{{{\mathit{cvtop}}{\mathsf{\_}}}{\mathit{nt}_{2}}}{\mathsf{\_}}}{{\mathit{sx}^?}}) &\hookrightarrow& (\mathit{nt}.\mathsf{const}~\mathit{c}) &\quad
  \mbox{if}~\mathrm{cvtop}(\mathit{nt}_{1},\, \mathit{cvtop},\, \mathit{nt}_{2},\, {\mathit{sx}^?},\, \mathit{c}_{1}) = \mathit{c} \\
{[\textsc{\scriptsize E{-}cvtop{-}trap}]} \quad & (\mathit{nt}.\mathsf{const}~\mathit{c}_{1})~(\mathit{nt}_{1} . {{{{\mathit{cvtop}}{\mathsf{\_}}}{\mathit{nt}_{2}}}{\mathsf{\_}}}{{\mathit{sx}^?}}) &\hookrightarrow& \mathsf{trap} &\quad
  \mbox{if}~\mathrm{cvtop}(\mathit{nt}_{1},\, \mathit{cvtop},\, \mathit{nt}_{2},\, {\mathit{sx}^?},\, \mathit{c}_{1}) = \epsilon \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}ref.func}]} \quad & \mathit{z} ; (\mathsf{ref.func}~\mathit{x}) &\hookrightarrow& (\mathsf{ref.func}~\mathit{z}.\mathsf{module}.\mathsf{func}[\mathit{x}]) &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}ref.is\_null{-}true}]} \quad & \mathit{val}~\mathsf{ref.is\_null} &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~1) &\quad
  \mbox{if}~\mathit{val} = (\mathsf{ref.null}~\mathit{rt}) \\
{[\textsc{\scriptsize E{-}ref.is\_null{-}false}]} \quad & \mathit{val}~\mathsf{ref.is\_null} &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~0) &\quad
  \mbox{otherwise} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}local.get}]} \quad & \mathit{z} ; (\mathsf{local.get}~\mathit{x}) &\hookrightarrow& {\mathit{z}.\mathsf{local}}{[\mathit{x}]} &  \\
\end{array}
$$

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}local.set}]} \quad & \mathit{z} ; \mathit{val}~(\mathsf{local.set}~\mathit{x}) &\hookrightarrow& \mathit{z}[\mathsf{local}[\mathit{x}] = \mathit{val}] ; \epsilon &  \\
\end{array}
$$

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}local.tee}]} \quad & \mathit{val}~(\mathsf{local.tee}~\mathit{x}) &\hookrightarrow& \mathit{val}~\mathit{val}~(\mathsf{local.set}~\mathit{x}) &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}global.get}]} \quad & \mathit{z} ; (\mathsf{global.get}~\mathit{x}) &\hookrightarrow& {\mathit{z}.\mathsf{global}}{[\mathit{x}]} &  \\
\end{array}
$$

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}global.set}]} \quad & \mathit{z} ; \mathit{val}~(\mathsf{global.set}~\mathit{x}) &\hookrightarrow& \mathit{z}[\mathsf{global}[\mathit{x}] = \mathit{val}] ; \epsilon &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}table.get{-}trap}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{table.get}~\mathit{x}) &\hookrightarrow& \mathsf{trap} &\quad
  \mbox{if}~\mathit{i} \geq {|{\mathit{z}.\mathsf{table}}{[\mathit{x}]}|} \\
{[\textsc{\scriptsize E{-}table.get{-}val}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{table.get}~\mathit{x}) &\hookrightarrow& {\mathit{z}.\mathsf{table}}{[\mathit{x}]}[\mathit{i}] &\quad
  \mbox{if}~\mathit{i} < {|{\mathit{z}.\mathsf{table}}{[\mathit{x}]}|} \\
{[\textsc{\scriptsize E{-}table.set{-}trap}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~\mathit{ref}~(\mathsf{table.get}~\mathit{x}) &\hookrightarrow& \mathsf{trap} &\quad
  \mbox{if}~\mathit{i} \geq {|{\mathit{z}.\mathsf{table}}{[\mathit{x}]}|} \\
\end{array}
$$

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}table.set{-}val}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~\mathit{ref}~(\mathsf{table.get}~\mathit{x}) &\hookrightarrow& \mathit{z}[\mathsf{table}[\mathit{x}][\mathit{i}] = \mathit{ref}] ; \epsilon &\quad
  \mbox{if}~\mathit{i} < {|{\mathit{z}.\mathsf{table}}{[\mathit{x}]}|} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}table.size}]} \quad & \mathit{z} ; (\mathsf{table.size}~\mathit{x}) &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n}) &\quad
  \mbox{if}~{|{\mathit{z}.\mathsf{table}}{[\mathit{x}]}|} = \mathit{n} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}table.grow{-}succeed}]} \quad & \mathit{z} ; \mathit{ref}~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.grow}~\mathit{x}) &\hookrightarrow& \mathit{z}[\mathsf{table}[\mathit{x}] = ..{\mathit{ref}^{\mathit{n}}}] ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~{|{\mathit{z}.\mathsf{table}}{[\mathit{x}]}|}) &  \\
\end{array}
$$

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}table.grow{-}fail}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.grow}~\mathit{x}) &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~-1) &  \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}table.fill{-}trap}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~\mathit{val}~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.fill}~\mathit{x}) &\hookrightarrow& \mathsf{trap} &\quad
  \mbox{if}~\mathit{i} + \mathit{n} > {|{\mathit{z}.\mathsf{table}}{[\mathit{x}]}|} \\
{[\textsc{\scriptsize E{-}table.fill{-}zero}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~\mathit{val}~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.fill}~\mathit{x}) &\hookrightarrow& \epsilon &\quad
  \mbox{otherwise, if}~\mathit{n} = 0 \\
{[\textsc{\scriptsize E{-}table.fill{-}succ}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~\mathit{val}~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.fill}~\mathit{x}) &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~\mathit{val}~(\mathsf{table.set}~\mathit{x})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i} + 1)~\mathit{val}~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n} - 1)~(\mathsf{table.fill}~\mathit{x}) &\quad
  \mbox{otherwise} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}table.copy{-}trap}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.copy}~\mathit{x}~\mathit{y}) &\hookrightarrow& \mathsf{trap} &\quad
  \mbox{if}~\mathit{i} + \mathit{n} > {|{\mathit{z}.\mathsf{table}}{[\mathit{y}]}|} \lor \mathit{j} + \mathit{n} > {|{\mathit{z}.\mathsf{table}}{[\mathit{x}]}|} \\
{[\textsc{\scriptsize E{-}table.copy{-}zero}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.copy}~\mathit{x}~\mathit{y}) &\hookrightarrow& \epsilon &\quad
  \mbox{otherwise, if}~\mathit{n} = 0 \\
{[\textsc{\scriptsize E{-}table.copy{-}le}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.copy}~\mathit{x}~\mathit{y}) &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{table.get}~\mathit{y})~(\mathsf{table.set}~\mathit{x})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j} + 1)~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i} + 1)~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n} - 1)~(\mathsf{table.copy}~\mathit{x}~\mathit{y}) &\quad
  \mbox{otherwise, if}~\mathit{j} \leq \mathit{i} \\
{[\textsc{\scriptsize E{-}table.copy{-}gt}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.copy}~\mathit{x}~\mathit{y}) &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j} + \mathit{n} - 1)~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i} + \mathit{n} - 1)~(\mathsf{table.get}~\mathit{y})~(\mathsf{table.set}~\mathit{x})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j} + 1)~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i} + 1)~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n} - 1)~(\mathsf{table.copy}~\mathit{x}~\mathit{y}) &\quad
  \mbox{otherwise} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}table.init{-}trap}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.init}~\mathit{x}~\mathit{y}) &\hookrightarrow& \mathsf{trap} &\quad
  \mbox{if}~\mathit{i} + \mathit{n} > {|{\mathit{z}.\mathsf{elem}}{[\mathit{y}]}|} \lor \mathit{j} + \mathit{n} > {|{\mathit{z}.\mathsf{table}}{[\mathit{x}]}|} \\
{[\textsc{\scriptsize E{-}table.init{-}zero}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.init}~\mathit{x}~\mathit{y}) &\hookrightarrow& \epsilon &\quad
  \mbox{otherwise, if}~\mathit{n} = 0 \\
{[\textsc{\scriptsize E{-}table.init{-}succ}]} \quad & \mathit{z} ; (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n})~(\mathsf{table.init}~\mathit{x}~\mathit{y}) &\hookrightarrow& (\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j})~{\mathit{z}.\mathsf{elem}}{[\mathit{y}]}[\mathit{i}]~(\mathsf{table.set}~\mathit{x})~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{j} + 1)~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{i} + 1)~(\mathsf{i{\scriptstyle32}}.\mathsf{const}~\mathit{n} - 1)~(\mathsf{table.init}~\mathit{x}~\mathit{y}) &\quad
  \mbox{otherwise} \\
\end{array}
$$

\vspace{1ex}

$$
\begin{array}{@{}l@{}lcl@{}l@{}}
{[\textsc{\scriptsize E{-}elem.drop}]} \quad & \mathit{z} ; (\mathsf{elem.drop}~\mathit{x}) &\hookrightarrow& \mathit{z}[\mathsf{elem}[\mathit{x}] = \epsilon] ; \epsilon &  \\
\end{array}
$$

\vspace{1ex}



local.set
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([SubE (VarE "val", VarT "val", VarT "admininstr"), CaseE (Atom "LOCAL.SET", VarT "admininstr", VarE "x")])]))

global.set
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([SubE (VarE "val", VarT "val", VarT "admininstr"), CaseE (Atom "GLOBAL.SET", VarT "admininstr", VarE "x")])]))

table.set-val
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "i"])), SubE (VarE "ref", VarT "ref", VarT "admininstr"), CaseE (Atom "TABLE.GET", VarT "admininstr", VarE "x")])]))

table.grow-succeed
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([SubE (VarE "ref", VarT "ref", VarT "admininstr"), CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "n"])), CaseE (Atom "TABLE.GROW", VarT "admininstr", VarE "x")])]))

elem.drop
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "ELEM.DROP", VarT "admininstr", VarE "x")])]))

call
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "CALL", VarT "admininstr", VarE "x")])]))

call_indirect-call
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "i"])), CaseE (Atom "CALL_INDIRECT", VarT "admininstr", TupE ([VarE "x", VarE "ft"]))])]))

call_addr
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", CatE (IterE (SubE (VarE "val", VarT "val", VarT "admininstr"), (ListN (VarE "k"), ["val"])), ListE ([CaseE (Atom "CALL_ADDR", VarT "admininstr", VarE "a")]))]))

ref.func
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "REF.FUNC", VarT "admininstr", VarE "x")])]))

local.get
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "LOCAL.GET", VarT "admininstr", VarE "x")])]))

global.get
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "GLOBAL.GET", VarT "admininstr", VarE "x")])]))

table.get-trap
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "i"])), CaseE (Atom "TABLE.GET", VarT "admininstr", VarE "x")])]))

table.size
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "TABLE.SIZE", VarT "admininstr", VarE "x")])]))

table.fill-trap
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "i"])), SubE (VarE "val", VarT "val", VarT "admininstr"), CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "n"])), CaseE (Atom "TABLE.FILL", VarT "admininstr", VarE "x")])]))

table.copy-trap
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "j"])), CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "i"])), CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "n"])), CaseE (Atom "TABLE.COPY", VarT "admininstr", TupE ([VarE "x", VarE "y"]))])]))

table.init-trap
MixE ([[], [Semicolon], [Star]], TupE ([VarE "z", ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "j"])), CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "i"])), CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "n"])), CaseE (Atom "TABLE.INIT", VarT "admininstr", TupE ([VarE "x", VarE "y"]))])]))

unreachable
ListE ([CaseE (Atom "UNREACHABLE", VarT "admininstr", TupE ([]))])

nop
ListE ([CaseE (Atom "NOP", VarT "admininstr", TupE ([]))])

drop
ListE ([SubE (VarE "val", VarT "val", VarT "admininstr"), CaseE (Atom "DROP", VarT "admininstr", TupE ([]))])

select-true
ListE ([SubE (VarE "val_1", VarT "val", VarT "admininstr"), SubE (VarE "val_2", VarT "val", VarT "admininstr"), CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "c"])), CaseE (Atom "SELECT", VarT "admininstr", IterE (VarE "t", (Opt, ["t"])))])

block
CatE (IterE (SubE (VarE "val", VarT "val", VarT "admininstr"), (ListN (VarE "k"), ["val"])), ListE ([CaseE (Atom "BLOCK", VarT "admininstr", TupE ([VarE "bt", IterE (VarE "instr", (List, ["instr"]))]))]))

loop
CatE (IterE (SubE (VarE "val", VarT "val", VarT "admininstr"), (ListN (VarE "k"), ["val"])), ListE ([CaseE (Atom "LOOP", VarT "admininstr", TupE ([VarE "bt", IterE (VarE "instr", (List, ["instr"]))]))]))

if-true
ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "c"])), CaseE (Atom "IF", VarT "admininstr", TupE ([VarE "bt", IterE (VarE "instr_1", (List, ["instr_1"])), IterE (VarE "instr_2", (List, ["instr_2"]))]))])

label-vals
ListE ([CaseE (Atom "LABEL_", VarT "admininstr", TupE ([VarE "n", IterE (VarE "instr", (List, ["instr"])), IterE (SubE (VarE "val", VarT "val", VarT "admininstr"), (List, ["val"]))]))])

br-zero
ListE ([CaseE (Atom "LABEL_", VarT "admininstr", TupE ([VarE "n", IterE (VarE "instr'", (List, ["instr'"])), CatE (IterE (SubE (VarE "val'", VarT "val", VarT "admininstr"), (List, ["val'"])), CatE (IterE (SubE (VarE "val", VarT "val", VarT "admininstr"), (ListN (VarE "n"), ["val"])), CatE (ListE ([CaseE (Atom "BR", VarT "admininstr", NatE 0)]), IterE (SubE (VarE "instr", VarT "instr", VarT "admininstr"), (List, ["instr"])))))]))])

br_if-true
ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "c"])), CaseE (Atom "BR_IF", VarT "admininstr", VarE "l")])

br_table-lt
ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([CaseE (Atom "I32", VarT "numtype", TupE ([])), VarE "i"])), CaseE (Atom "BR_TABLE", VarT "admininstr", TupE ([IterE (VarE "l", (List, ["l"])), VarE "l'"]))])

frame-vals
ListE ([CaseE (Atom "FRAME_", VarT "admininstr", TupE ([VarE "n", VarE "f", IterE (SubE (VarE "val", VarT "val", VarT "admininstr"), (ListN (VarE "n"), ["val"]))]))])

return-frame
ListE ([CaseE (Atom "FRAME_", VarT "admininstr", TupE ([VarE "n", VarE "f", CatE (IterE (SubE (VarE "val'", VarT "val", VarT "admininstr"), (List, ["val'"])), CatE (IterE (SubE (VarE "val", VarT "val", VarT "admininstr"), (ListN (VarE "n"), ["val"])), CatE (ListE ([CaseE (Atom "RETURN", VarT "admininstr", TupE ([]))]), IterE (SubE (VarE "instr", VarT "instr", VarT "admininstr"), (List, ["instr"])))))]))])

unop-val
ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([VarE "nt", VarE "c_1"])), CaseE (Atom "UNOP", VarT "admininstr", TupE ([VarE "nt", VarE "unop"]))])

binop-val
ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([VarE "nt", VarE "c_1"])), CaseE (Atom "CONST", VarT "admininstr", TupE ([VarE "nt", VarE "c_2"])), CaseE (Atom "BINOP", VarT "admininstr", TupE ([VarE "nt", VarE "binop"]))])

testop
ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([VarE "nt", VarE "c_1"])), CaseE (Atom "TESTOP", VarT "admininstr", TupE ([VarE "nt", VarE "testop"]))])

relop
ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([VarE "nt", VarE "c_1"])), CaseE (Atom "CONST", VarT "admininstr", TupE ([VarE "nt", VarE "c_2"])), CaseE (Atom "RELOP", VarT "admininstr", TupE ([VarE "nt", VarE "relop"]))])

extend
ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([VarE "nt", VarE "c"])), CaseE (Atom "EXTEND", VarT "admininstr", TupE ([VarE "nt", VarE "n"]))])

cvtop-val
ListE ([CaseE (Atom "CONST", VarT "admininstr", TupE ([VarE "nt", VarE "c_1"])), CaseE (Atom "CVTOP", VarT "admininstr", TupE ([VarE "nt_1", VarE "cvtop", VarE "nt_2", IterE (VarE "sx", (Opt, ["sx"]))]))])

ref.is_null-true
ListE ([SubE (VarE "val", VarT "val", VarT "admininstr"), CaseE (Atom "REF.IS_NULL", VarT "admininstr", TupE ([]))])

local.tee
ListE ([SubE (VarE "val", VarT "val", VarT "admininstr"), CaseE (Atom "LOCAL.TEE", VarT "admininstr", VarE "x")])
local.tee
1. Assert: Yet.
2. Pop YetE ((val <: admininstr)) from the stack.
3. Push YetE ((val <: admininstr)) to the stack.
4. Push YetE ((val <: admininstr)) to the stack.
5. Execute (LOCAL.SET YetE (x)).

ref.is_null-true
1. Assert: Yet.
2. Pop YetE ((val <: admininstr)) from the stack.
3. If YetC (), then:
  a. Push YetE (CONST_admininstr(I32_numtype, 1)) to the stack.
4. If YetC (), then:
  a. Push YetE (CONST_admininstr(I32_numtype, 0)) to the stack.

cvtop-val
1. Assert: Yet.
2. Pop YetE (CONST_admininstr(nt, c_1)) from the stack.
3. If YetC (), then:
  a. Push YetE (CONST_admininstr(nt, c)) to the stack.
4. If YetC (), then:
  a. Trap.

extend
1. Assert: Yet.
2. Pop YetE (CONST_admininstr(nt, c)) from the stack.
3. Push YetE (CONST_admininstr(nt, $ext(n, $size(nt <: valtype), S_sx, c))) to the stack.

relop
1. Assert: Yet.
2. Pop YetE (CONST_admininstr(nt, c_1)) from the stack.
3. Assert: Yet.
4. Pop YetE (CONST_admininstr(nt, c_2)) from the stack.
5. Let YetE (c) be YetE ($relop(relop, nt, c_1, c_2)).
6. Push YetE (CONST_admininstr(I32_numtype, c)) to the stack.

testop
1. Assert: Yet.
2. Pop YetE (CONST_admininstr(nt, c_1)) from the stack.
3. Let YetE (c) be YetE ($testop(testop, nt, c_1)).
4. Push YetE (CONST_admininstr(I32_numtype, c)) to the stack.

binop-val
1. Assert: Yet.
2. Pop YetE (CONST_admininstr(nt, c_1)) from the stack.
3. Assert: Yet.
4. Pop YetE (CONST_admininstr(nt, c_2)) from the stack.
5. If YetC (), then:
  a. Push YetE (CONST_admininstr(nt, c)) to the stack.
6. If YetC (), then:
  a. Trap.

unop-val
1. Assert: Yet.
2. Pop YetE (CONST_admininstr(nt, c_1)) from the stack.
3. If YetC (), then:
  a. Push YetE (CONST_admininstr(nt, c)) to the stack.
4. If YetC (), then:
  a. Trap.

return-frame
1. If YetC (), then:
  a. Push YetE ((val <: admininstr)^n{val}) to the stack.
2. If YetC (), then:
  a. Push YetE ((val <: admininstr)*{val}) to the stack.
  b. Execute (RETURN).

frame-vals
1. Push YetE ((val <: admininstr)^n{val}) to the stack.

br_table-lt
1. Assert: Due to validation, a value of value type i32 is on the top of the stack.
2. Pop YetE (CONST_admininstr(I32_numtype, i)) from the stack.
3. If YetC (), then:
  a. Execute (BR YetE (l*{l}[i])).
4. If YetC (), then:
  a. Execute (BR YetE (l')).

br_if-true
1. Assert: Due to validation, a value of value type i32 is on the top of the stack.
2. Pop YetE (CONST_admininstr(I32_numtype, c)) from the stack.
3. If YetC (), then:
  a. Execute (BR YetE (l)).
4. If YetC (), then:

br-zero
1. If YetC (), then:
  a. Push YetE ((val <: admininstr)^n{val}) to the stack.
  b. Push YetE ((instr' <: admininstr)*{instr'}) to the stack.
2. If YetC (), then:
  a. Push YetE ((val <: admininstr)*{val}) to the stack.
  b. Execute (BR YetE (l)).

label-vals
1. Push YetE ((val <: admininstr)*{val}) to the stack.

if-true
1. Assert: Due to validation, a value of value type i32 is on the top of the stack.
2. Pop YetE (CONST_admininstr(I32_numtype, c)) from the stack.
3. If YetC (), then:
  a. Execute (BLOCK YetE (bt) YetE (instr_1*{instr_1})).
4. If YetC (), then:
  a. Execute (BLOCK YetE (bt) YetE (instr_2*{instr_2})).

loop
1. Pop YetE ((val <: admininstr)^k{val}) from the stack.
2. Let YetE (bt) be YetE (`%->%`(t_1^k{t_1}, t_2^n{t_2})).
3. Let L be YetE ().
4. Enter the block  with label YetE ().

block
1. Pop YetE ((val <: admininstr)^k{val}) from the stack.
2. Let YetE (bt) be YetE (`%->%`(t_1^k{t_1}, t_2^n{t_2})).
3. Let L be YetE ().
4. Enter the block  with label YetE ().

select-true
1. Assert: Yet.
2. Pop YetE ((val_1 <: admininstr)) from the stack.
3. Assert: Yet.
4. Pop YetE ((val_2 <: admininstr)) from the stack.
5. Assert: Due to validation, a value of value type i32 is on the top of the stack.
6. Pop YetE (CONST_admininstr(I32_numtype, c)) from the stack.
7. If YetC (), then:
  a. Push YetE ((val_1 <: admininstr)) to the stack.
8. If YetC (), then:
  a. Push YetE ((val_2 <: admininstr)) to the stack.

drop
1. Assert: Yet.
2. Pop YetE ((val <: admininstr)) from the stack.

nop

unreachable
1. Trap.

table.init-trap
1. Assert: Due to validation, a value of value type i32 is on the top of the stack.
2. Pop YetE (CONST_admininstr(I32_numtype, j)) from the stack.
3. Assert: Due to validation, a value of value type i32 is on the top of the stack.
4. Pop YetE (CONST_admininstr(I32_numtype, i)) from the stack.
5. Assert: Due to validation, a value of value type i32 is on the top of the stack.
6. Pop YetE (CONST_admininstr(I32_numtype, n)) from the stack.
7. If YetC (), then:
  a. Trap.
8. If YetC (), then:
9. If YetC (), then:
  a. Push YetE (CONST_admininstr(I32_numtype, j)) to the stack.
  b. Push YetE (($elem(z, y)[i] <: admininstr)) to the stack.
  c. Execute (TABLE.SET YetE (x)).
  d. Push YetE (CONST_admininstr(I32_numtype, (j + 1))) to the stack.
  e. Push YetE (CONST_admininstr(I32_numtype, (i + 1))) to the stack.
  f. Push YetE (CONST_admininstr(I32_numtype, (n - 1))) to the stack.
  g. Execute (TABLE.INIT YetE (x) YetE (y)).

table.copy-trap
1. Assert: Due to validation, a value of value type i32 is on the top of the stack.
2. Pop YetE (CONST_admininstr(I32_numtype, j)) from the stack.
3. Assert: Due to validation, a value of value type i32 is on the top of the stack.
4. Pop YetE (CONST_admininstr(I32_numtype, i)) from the stack.
5. Assert: Due to validation, a value of value type i32 is on the top of the stack.
6. Pop YetE (CONST_admininstr(I32_numtype, n)) from the stack.
7. If YetC (), then:
  a. Trap.
8. If YetC (), then:
9. If YetC (), then:
  a. Push YetE (CONST_admininstr(I32_numtype, j)) to the stack.
  b. Push YetE (CONST_admininstr(I32_numtype, i)) to the stack.
  c. Execute (TABLE.GET YetE (y)).
  d. Execute (TABLE.SET YetE (x)).
  e. Push YetE (CONST_admininstr(I32_numtype, (j + 1))) to the stack.
  f. Push YetE (CONST_admininstr(I32_numtype, (i + 1))) to the stack.
  g. Push YetE (CONST_admininstr(I32_numtype, (n - 1))) to the stack.
  h. Execute (TABLE.COPY YetE (x) YetE (y)).
10. If YetC (), then:
  a. Push YetE (CONST_admininstr(I32_numtype, ((j + n) - 1))) to the stack.
  b. Push YetE (CONST_admininstr(I32_numtype, ((i + n) - 1))) to the stack.
  c. Execute (TABLE.GET YetE (y)).
  d. Execute (TABLE.SET YetE (x)).
  e. Push YetE (CONST_admininstr(I32_numtype, (j + 1))) to the stack.
  f. Push YetE (CONST_admininstr(I32_numtype, (i + 1))) to the stack.
  g. Push YetE (CONST_admininstr(I32_numtype, (n - 1))) to the stack.
  h. Execute (TABLE.COPY YetE (x) YetE (y)).

table.fill-trap
1. Assert: Due to validation, a value of value type i32 is on the top of the stack.
2. Pop YetE (CONST_admininstr(I32_numtype, i)) from the stack.
3. Assert: Yet.
4. Pop YetE ((val <: admininstr)) from the stack.
5. Assert: Due to validation, a value of value type i32 is on the top of the stack.
6. Pop YetE (CONST_admininstr(I32_numtype, n)) from the stack.
7. If YetC (), then:
  a. Trap.
8. If YetC (), then:
9. If YetC (), then:
  a. Push YetE (CONST_admininstr(I32_numtype, i)) to the stack.
  b. Push YetE ((val <: admininstr)) to the stack.
  c. Execute (TABLE.SET YetE (x)).
  d. Push YetE (CONST_admininstr(I32_numtype, (i + 1))) to the stack.
  e. Push YetE ((val <: admininstr)) to the stack.
  f. Push YetE (CONST_admininstr(I32_numtype, (n - 1))) to the stack.
  g. Execute (TABLE.FILL YetE (x)).

table.size
1. Let YetE (|$table(z, x)|) be YetE (n).
2. Push YetE (CONST_admininstr(I32_numtype, n)) to the stack.

table.get-trap
1. Assert: Due to validation, a value of value type i32 is on the top of the stack.
2. Pop YetE (CONST_admininstr(I32_numtype, i)) from the stack.
3. If YetC (), then:
  a. Trap.
4. If YetC (), then:
  a. Push YetE (($table(z, x)[i] <: admininstr)) to the stack.

global.get
1. Push YetE (($global(z, x) <: admininstr)) to the stack.

local.get
1. Push YetE (($local(z, x) <: admininstr)) to the stack.

ref.func
1. Push YetE (REF.FUNC_ADDR_admininstr($funcaddr(z)[x])) to the stack.

call_addr
1. Pop YetE ((val <: admininstr)^k{val}) from the stack.
2. Let YetE ($funcinst(z)[a]) be YetE (`%;%`(m, `FUNC%%*%`(`%->%`(t_1^k{t_1}, t_2^n{t_2}), t*{t}, instr*{instr}))).
3. Let YetE (f) be YetE ({LOCAL val^k{val} :: $default_(t)*{t}, MODULE m}).
4. Let F be the current frame.
5. Push YetE ((n, f, [LABEL__admininstr(n, [], (instr <: admininstr)*{instr})])) to the stack.

call_indirect-call
1. Assert: Due to validation, a value of value type i32 is on the top of the stack.
2. Pop YetE (CONST_admininstr(I32_numtype, i)) from the stack.
3. If YetC (), then:
  a. Invoke the function instance at address YetE (a).
4. If YetC (), then:
  a. Trap.

call
1. Invoke the function instance at address YetE ($funcaddr(z)[x]).

elem.drop
1. YetI: Perform $with_elem(z, x, []).

table.grow-succeed
1. Assert: Yet.
2. Pop YetE ((ref <: admininstr)) from the stack.
3. Assert: Due to validation, a value of value type i32 is on the top of the stack.
4. Pop YetE (CONST_admininstr(I32_numtype, n)) from the stack.
5. If YetC (), then:
  a. YetI: Perform $with_tableext(z, x, ref^n{}).
  b. Push YetE (CONST_admininstr(I32_numtype, |$table(z, x)|)) to the stack.
6. If YetC (), then:
  a. Push YetE (CONST_admininstr(I32_numtype, - 1)) to the stack.

table.set-val
1. Assert: Due to validation, a value of value type i32 is on the top of the stack.
2. Pop YetE (CONST_admininstr(I32_numtype, i)) from the stack.
3. Assert: Yet.
4. Pop YetE ((ref <: admininstr)) from the stack.
5. If YetC (), then:
  a. YetI: Perform $with_table(z, x, i, ref).
6. If YetC (), then:
  a. Trap.

global.set
1. Assert: Yet.
2. Pop YetE ((val <: admininstr)) from the stack.
3. YetI: Perform $with_global(z, x, val).

local.set
1. Assert: Yet.
2. Pop YetE ((val <: admininstr)) from the stack.
3. YetI: Perform $with_local(z, x, val).

