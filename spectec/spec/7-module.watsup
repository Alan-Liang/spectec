;; Module Semantics

def $alloc_import(moduleinst, import*, externval*) : moduleinst

def $alloc_import(m, epsilon, epsilon) = m

def $alloc_import(m, import import'*, externval externval'*) = m_res
  -- if import = IMPORT name name' externtype
  -- if externtype = FUNC functype
  -- if externval = FUNC fa
  -- if m_new = m[.FUNC =.. fa]
  -- if m_res = $alloc_import(m_new, import'*, externval'*)

def $alloc_import(m, import import'*, externval externval'*) = m_res
  -- if import = IMPORT name name' externtype
  -- if externtype = GLOBAL globaltype
  -- if externval = GLOBAL ga
  -- if m_new = m[.GLOBAL =.. ga]
  -- if m_res = $alloc_import(m_new, import'*, externval'*)

def $alloc_import(m, import import'*, externval externval'*) = m_res
  -- if import = IMPORT name name' externtype
  -- if externtype = TABLE tabletype
  -- if externval = TABLE ta
  -- if m_new = m[.TABLE =.. ta]
  -- if m_res = $alloc_import(m_new, import'*, externval'*)

def $alloc_import(m, import import'*, externval externval'*) = m_res
  -- if import = IMPORT name name' externtype
  -- if externtype = MEM memtype
  -- if externval = MEM ma
  -- if m_new = m[.MEM =.. ma]
  -- if m_res = $alloc_import(m_new, import'*, externval'*)


def $alloc_func(state, func*) : (store, funcaddr*)

def $alloc_func((s; f), epsilon) = (s, epsilon)

def $alloc_func((s; f), func func'*) = (s_res, fa fa'*)
  -- if fi = { MODULE f.MODULE, CODE func }
  -- if fa = |$funcinst((s; f))|
  -- if s_new = s[.FUNC =.. fi]
  -- if (s_res, fa'*) = $alloc_func((s_new; f), func'*)


def $alloc_global(state, global*) : (store, globaladdr*)

def $alloc_global((s; f), epsilon) = (s, epsilon)

def $alloc_global((s; f), global global'*) = (s_res, ga ga'*)
  -- if global = GLOBAL globaltype instr*
  -- Step_read : s; f; instr* ~> val
  -- if gi = { TYPE globaltype, VALUE val }
  -- if ga = |$globalinst((s; f))|
  -- if s_new = s[.GLOBAL =.. gi]
  -- if (s_res, ga'*) = $alloc_global((s_new; f), global'*)


def $alloc_table(state, table*) : (store, tableaddr*)

def $alloc_table((s; f), epsilon) = (s, epsilon)

def $alloc_table((s; f), table table'*) = (s_res, ta ta'*)
  -- if table = TABLE tabletype
  -- if tabletype = `[i .. j?] reftype
  -- if ti = { TYPE tabletype, ELEM (REF.NULL reftype)^i }
  -- if ta = |$tableinst((s; f))|
  -- if s_new = s[.TABLE =.. ti]
  -- if (s_res, ta'*) = $alloc_table((s_new; f), table'*)


def $alloc_mem(state, mem*) : (store, memaddr*)

def $alloc_mem((s; f), epsilon) = (s, epsilon)

def $alloc_mem((s; f), mem mem'*) = (s_res, ma ma'*)
  -- if mem = MEMORY memtype
  -- if memtype = `[i .. j?] I8
  -- if mi = { TYPE memtype, DATA 0^(i * 64 * $Ki()) }
  -- if ma = |$meminst((s; f))|
  -- if s_new = s[.MEM =.. mi]
  -- if (s_res, ma'*) = $alloc_mem((s_new; f), mem'*)


def $alloc_elem(state, elem*) : (store, elemaddr*)

def $alloc_elem((s; f), epsilon) = (s, epsilon)

def $alloc_elem((s; f), elem elem'*) = (s_res, ea ea'*)
  -- if elem = ELEM reftype (instr*)* elemmode?
  -- (Step_read : s; f; instr* ~> ref)*
  -- if ei = { TYPE reftype, ELEM ref* }
  -- if ea = |$eleminst((s; f))|
  -- if s_new = s[.ELEM =.. ei]
  -- if (s_res, ea'*) = $alloc_elem((s_new; f), elem'*)


def $alloc_data(state, data*) : (store, dataaddr*)

def $alloc_data((s; f), epsilon) = (s, epsilon)

def $alloc_data((s; f), data data'*) = (s_res, da da'*)
  -- if data = DATA byte* datamode?
  -- if di = { DATA byte* }
  -- if da = |$datainst((s; f))|
  -- if s_new = s[.DATA =.. di]
  -- if (s_res, da'*) = $alloc_data((s_new; f), data'*)


def $replace_moduleinst(store, funcaddr*, moduleinst) : store

def $replace_moduleinst(s, epsilon, m) = s

def $replace_moduleinst(s, fa fa'*, m) = s_res
  -- if s_new = s[.FUNC[fa].MODULE = m]
  -- if s_res = $replace_moduleinst(s_new, fa'*, m)


def $alloc_export(moduleinst, export) : exportinst

def $alloc_export(m, export) = xi
  -- if export = EXPORT name externuse
  -- if externuse = FUNC x
  -- if externval = FUNC m.FUNC[x]
  -- if xi = { NAME name, VALUE externval }

def $alloc_export(m, export) = xi
  -- if export = EXPORT name externuse
  -- if externuse = GLOBAL x
  -- if externval = GLOBAL m.GLOBAL[x]
  -- if xi = { NAME name, VALUE externval }

def $alloc_export(m, export) = xi
  -- if export = EXPORT name externuse
  -- if externuse = TABLE x
  -- if externval = TABLE m.TABLE[x]
  -- if xi = { NAME name, VALUE externval }

def $alloc_export(m, export) = xi
  -- if export = EXPORT name externuse
  -- if externuse = MEM x
  -- if externval = MEM m.MEM[x]
  -- if xi = { NAME name, VALUE externval }


def $alloc_module(store, module, externval*) : (store, moduleinst)

def $alloc_module(s, module, externval*) = (s_res, m_res)
  -- if module = MODULE import* func* global* table* mem* elem* data* start? export*
  -- if m_init = { FUNC epsilon, GLOBAL epsilon, TABLE epsilon, MEM epsilon, ELEM epsilon, DATA epsilon, EXPORT epsilon }
  -- if m_im = $alloc_import(m_init, import*, externval*)
  -- if f = { LOCAL epsilon, MODULE m_im }
  -- if (s_func, fa*) = $alloc_func((s; f), func*)
  -- if (s_global, ga*) = $alloc_global((s_func; f), global*)
  -- if (s_table, ta*) = $alloc_table((s_global; f), table*)
  -- if (s_mem, ma*) = $alloc_mem((s_table; f), mem*)
  -- if (s_elem, ea*) = $alloc_elem((s_mem; f), elem*)
  -- if (s_data, da*) = $alloc_data((s_elem; f), data*)
  -- if m_ex = m_im ++ { FUNC fa*, GLOBAL ga*, TABLE ta*, MEM ma*, ELEM ea*, DATA da*, EXPORT epsilon }
  -- if xi* = $alloc_export(m_ex, export)*
  -- if m_res = m_ex[.EXPORT = xi*]
  -- if s_res = $replace_moduleinst(s_data, fa*, m_res)


def $run_elem(state, elem*, idx) : state

def $run_elem((s; f), epsilon, i) = s; f

def $run_elem((s; f), elem elem'*, i) = s_res; f_res
  -- if elem = ELEM reftype expr*
  -- if $run_elem((s; f), elem'*, $(i + 1)) = s_res; f_res

def $run_elem((s; f), elem elem'*, i) = s_res; f_res
  -- if elem = ELEM reftype expr* elemmode
  -- if n = |expr*|
  -- if elemmode = TABLE x instr*
  -- Step : s; f; instr* (CONST I32 0) (CONST I32 n) (TABLE.INIT x i) (ELEM.DROP i) ~> s_new; f_new; epsilon
  -- if $run_elem((s_new; f_new), elem'*, $(i + 1)) = s_res; f_res

def $run_elem((s; f), elem elem'*, i) = s_res; f_res
  -- if elem = ELEM reftype expr* elemmode
  -- if elemmode = DECLARE
  -- Step : s; f; (ELEM.DROP i) ~> s_new; f_new; epsilon
  -- if $run_elem((s_new; f_new), elem'*, $(i + 1)) = s_res; f_res


def $run_data(state, data*, idx) : state

def $run_data((s; f), epsilon, i) = s; f

def $run_data((s; f), data data'*, i) = s_res; f_res
  -- if data = DATA byte*
  -- if $run_data((s; f), data'*, $(i + 1)) = s_res; f_res

def $run_data((s; f), data data'*, i) = s_res; f_res
  -- if data = DATA byte* datamode
  -- if n = |byte*|
  -- if datamode = MEMORY 0 instr*
  -- Step : s; f; instr* (CONST I32 0) (CONST I32 n) (MEMORY.INIT i) (DATA.DROP i) ~> s_new; f_new; epsilon
  -- if $run_data((s_new; f_new), data'*, $(i + 1)) = s_res; f_res


def $instantiation(store, module, externval*) : (store, moduleinst)

def $instantiation(s, module, externval*) = (s_res, m)
  -- if module = MODULE import* func* global* table* mem* elem* data* export*
  -- if (s_alloc, m) = $alloc_module(s, module, externval*)
  -- if f = { LOCAL epsilon, MODULE m }
  -- if $run_elem((s_alloc; f_alloc), elem*, 0) = s_elem; f_elem
  -- if $run_data((s_elem; f_elem), data*, 0) = s_res; f_res

def $instantiation(s, module, externval*) = (s_res, m)
  -- if module = MODULE import* func* global* table* mem* elem* data* start export*
  -- if (s_alloc, m) = $alloc_module(s, module, externval*)
  -- if f = { LOCAL epsilon, MODULE m }
  -- if $run_elem((s_alloc; f_alloc), elem*, 0) = s_elem; f_elem
  -- if $run_data((s_elem; f_elem), data*, 0) = s_data; f_data
  -- if start = START x
  -- Step : s_data; f_data; (CALL x) ~> s_res; f_res; epsilon


def $invocation(store, funcaddr, val*) : (store, val*)

def $invocation(s, fa, val*) = (s', val'*)
  -- if m = { FUNC epsilon, GLOBAL epsilon, TABLE epsilon, MEM epsilon, ELEM epsilon, DATA epsilon, EXPORT epsilon }
  -- if f = { LOCAL epsilon, MODULE m }
  -- if $funcinst((s; f))[fa].CODE = FUNC functype valtype* expr
  -- if functype = valtype* -> valtype'*
  -- if |val*| = |valtype*|
  -- if |val'*| = |valtype'*|
  -- Step : s; f; val* (CALL_ADDR fa) ~> s'; f'; val'*
